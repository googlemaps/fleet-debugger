{"version":3,"sources":["Map.js","queryString.js","Dataframe.js","TimeSlider.js","LogTable.js","ToggleBar.js","App.js","vehicleData.js","Utils.js","Trip.js","Stats.js","HighVelocityJump.js","MissingUpdate.js","TripLogs.js","index.js"],"names":["mapLoadedResolver","minDate","maxDate","map","apikey","trafficLayer","panorama","jwt","projectId","locationProvider","solutionType","tripLogs","setFeaturedObject","setTimeRange","setQueryStringWithoutPageReload","qsValue","newurl","window","location","protocol","host","pathname","history","pushState","path","getQueryStringValue","key","queryString","search","values","qs","parse","setQueryStringValue","value","newQsValue","stringify","mapLoadPromise","Promise","resolve","allPaths","allMarkers","dataMakers","bubbleMap","toggleHandlers","render","status","Status","LOADING","FAILURE","addTripPolys","_","forEach","p","setMap","m","lastVehicleCoords","trips","getTrips","vehicleBounds","google","maps","LatLngBounds","trip","bounds","tripCoords","getPathCoords","length","last","Polyline","geodesic","strokeColor","getColor","tripIdx","strokeOpacity","strokeWeight","event","addListener","setOptions","fd","getFeaturedData","firstUpdate","getTime","lastUpdate","getPath","e","extend","push","lastVehicleLocMark","Marker","position","icon","url","scaledSize","Size","title","MyMapComponent","ref","useRef","useEffect","element","urlZoom","urlCenter","current","journeySharing","FleetEngineTripLocationProvider","authTokenFetcher","options","console","log","token","JourneySharingMapView","setZoom","parseInt","setCenter","JSON","fitBounds","getZoom","debounce","getCenter","toJSON","id","style","height","colors","Map","props","logData","urlParams","URLSearchParams","get","apiKey","version","libraries","onSliderChangeMap","rangeStart","rangeEnd","Date","handler","name","GenerateBubbles","bubbleName","cb","showBubble","bubble","getLogs_","le","rawLocation","lastLocation","undefined","LatLng","lat","latitude","lng","longitude","compact","rawLocationLatLng","color","locSensor","accuracy","rawLocationAccuracy","circ","Circle","fillColor","fillOpacity","center","radius","logEntry","clientTimeStr","serverTimeStr","clientDate","serverDate","timeDeltaSeconds","Math","abs","heading","headingLine","icons","SymbolPath","FORWARD_CLOSED_ARROW","offset","geometry","spherical","computeOffset","StreetViewPanorama","document","getElementById","pov","pitch","addressControlOptions","ControlPosition","BOTTOM_CENTER","linksControl","panControl","enableCloseButton","speed","enabled","TrafficLayer","dwellLocations","getDwellLocations","dl","leaderCoords","updates","jumps","getHighVelocityJumps","jump","getStrokeWeight","velocity","startLoc","endLoc","jumpIdx","startDate","endDate","flatten","missingUpdates","getMissingUpdates","update","interval","offsetHeading","computeHeading","points","scale","CIRCLE","tripId","getTripIDs","Dataframe","src","featuredObject","onSelect","onClick","Range","createSliderWithTooltip","Slider","width","TimeSlider","marks","getTripStatusChanges","change","date","minVal","maxVal","curMin","max","curMax","min","step","onChange","onSliderChange","minTime","maxTime","defaultValue","tipFormatter","d","tripStatus","getTripStatusAtDate","Styles","styled","div","Table","columns","data","onSelectionChange","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","row","getRowProps","original","cells","cell","getCellProps","TrimCell","trim","replace","LogTable","timeRange","React","useMemo","stdColumns","Header","accessor","Cell","extraColumns","dotPath","elems","split","Button","button","ButtonToggle","active","ButtonGroup","ToggleBar","toggleState","toggles","toggle","clickHandler","href","docLink","target","rel","getToggleDefault","urlKey","defaultVal","App","nowDate","urlMinTime","urlMaxTime","initialMinTime","initialMaxTime","setFullYear","getFullYear","state","msg","toggleOptions","showGPSBubbles","showHeading","showSpeed","showTraffic","showDwellLocations","showHighVelocityJumps","showMissingUpdates","showLiveJS","showClientServerTimeDeltas","onSliderChangeDebounced","fo","then","updateToggleState","newValue","toggleName","jsonPaths","this","setState","prevState","updateMapToggles","clone","pull","uniq","selectedRow","svgMarker","rotation","anchor","Point","locationForLog","addMarkersToMapForData","select","jsonPath","join","namespace","find","x","without","toggleClickHandler","marginTop","overflowX","overFlowY","float","marginLeft","overFlowX","onDataframePropClick","Component","Utils","duration","sec_num","hours","floor","minutes","seconds","timeStr","Trip","tripName","updateRequests","pathCoords","tripDuration","creationTime","computeLength","formatDuration","traveledDistanceKilometers","getTraveledDistance","traveledDistanceMiles","filter","timestamp","trip_id","Stats","dataSet","sorted","sort","ceil","computedOutlier","HighVelocityJump","prevEntry","curEntry","prevLoc","curLoc","distanceTraveled","computeDistanceBetween","timeSpentMS","entry","velocityMPH","toString","computedOutlierVelocity","featureData","timestampMS","formattedDate","toISOString","jsonPayload","request","vehicle","velocities","avgVelocity","mean","medianVelocity","median","minVelocity","maxVelocity","sortBy","MissingUpdate","idx","startVehicleState","endVehicleState","temporal_gap","response","getStateTransition","intervals","avgInternal","medianInternal","minInternal","maxInternal","TripLogs","rawLogs","updateVehicleSuffix","lastLocationPath","vehicleName","trip_ids","tripStatusChanges","reverse","processTripSegments","velocityJumps","getRawLogs_","concat","j","getLogViewerEntry","u","sortedIndexBy","newStatus","entries","ret","getSignificantMissingUpdates","getSignificantJumps","coord","cluster","stopsLeft","curTripId","curTripData","nonTripIdx","lastTripStatus","logName","match","newTripId","getSegmentID","appendCoords","a","fetch","json","parsedData","APIKEY","loadData","ReactDOM"],"mappings":"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","file":"static/js/main.6cbcd1f9.chunk.js","sourcesContent":["/*\n * Map.js\n *\n * Uses the react-wrapper to make using google maps js sdk\n * easier in react.  Beyond basic loading doesn't pretend to\n * act like a normal react component.\n */\nimport { Wrapper, Status } from \"@googlemaps/react-wrapper\";\nimport { useEffect, useRef } from \"react\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\n\n/*\n * Expose a promise that resolves when the map is fully instantiated\n */\nlet mapLoadedResolver;\nconst mapLoadPromise = new Promise((resolve) => {\n  mapLoadedResolver = resolve;\n});\n\nlet minDate;\nlet maxDate;\nlet allPaths = [];\nlet allMarkers = [];\nlet map;\nlet apikey;\nlet dataMakers = [];\nlet trafficLayer;\nconst bubbleMap = {};\nconst toggleHandlers = {};\nlet panorama;\nlet jwt;\nlet projectId;\nlet locationProvider;\nlet solutionType;\nlet tripLogs;\nlet setFeaturedObject;\nlet setTimeRange;\n\nconst render = (status) => {\n  if (status === Status.LOADING) return <h3>{status} ..</h3>;\n  if (status === Status.FAILURE) return <h3>{status} ...</h3>;\n  return null;\n};\n\nfunction addTripPolys(map) {\n  _.forEach(allPaths, (p) => p.setMap(null));\n  allPaths = [];\n  _.forEach(allMarkers, (m) => m.setMap(null));\n  allMarkers = [];\n\n  const trips = tripLogs.getTrips();\n  const vehicleBounds = new window.google.maps.LatLngBounds();\n  let lastVehicleCoords;\n  _.forEach(trips, (trip) => {\n    const tripCoords = trip.getPathCoords(minDate, maxDate);\n    if (tripCoords.length > 0) {\n      lastVehicleCoords = _.last(tripCoords);\n      const path = new window.google.maps.Polyline({\n        path: tripCoords,\n        geodesic: true,\n        strokeColor: getColor(trip.tripIdx),\n        strokeOpacity: 0.5,\n        strokeWeight: 6,\n      });\n      google.maps.event.addListener(path, \"mouseover\", () => {\n        path.setOptions({\n          strokeOpacity: 1,\n          strokeWeight: 8,\n        });\n      });\n      google.maps.event.addListener(path, \"mouseout\", () => {\n        path.setOptions({\n          strokeOpacity: 0.5,\n          strokeWeight: 6,\n        });\n      });\n      google.maps.event.addListener(path, \"click\", () => {\n        const fd = trip.getFeaturedData();\n        setFeaturedObject(fd);\n        // TODO: https://github.com/googlemaps/fleet-debugger/issues/79\n        // this time range won't capture the createTrip logs\n        setTimeRange(fd.firstUpdate.getTime(), fd.lastUpdate.getTime());\n      });\n      getPolyBounds(vehicleBounds, path);\n      path.setMap(map);\n      allPaths.push(path);\n    }\n  });\n  if (lastVehicleCoords) {\n    const urlBase = \"http://maps.google.com/mapfiles/kml/shapes/\";\n    const lastVehicleLocMark = new window.google.maps.Marker({\n      position: lastVehicleCoords,\n      map: map,\n      icon: {\n        url: urlBase + (solutionType === \"LMFS\" ? \"truck.png\" : \"cabs.png\"),\n        scaledSize: new google.maps.Size(25, 25),\n      },\n      title: \"Last Location\",\n    });\n    allMarkers.push(lastVehicleLocMark);\n  }\n  return vehicleBounds;\n}\n\n/*\n * Creates the map object using a journeySharing location\n * provider.\n */\nfunction initializeMapObject(element) {\n  // In a more normal implementation authTokenFetcher\n  // would actually be making a RPC to a backend to generate\n  // the jwt.  For debugging use cases the jwt gets bundled into\n  // the extracted log data.\n  function authTokenFetcher(options) {\n    // TODO #25 - bake in actual expiration time -- and give a\n    // better error message for expired jwts\n    console.log(\"Ignoring options using prebuilt jwt\", options);\n    const authToken = {\n      token: jwt,\n    };\n    return authToken;\n  }\n\n  locationProvider =\n    new google.maps.journeySharing.FleetEngineTripLocationProvider({\n      projectId,\n      authTokenFetcher,\n    });\n  const jsMapView = new google.maps.journeySharing.JourneySharingMapView({\n    element: element,\n    locationProvider,\n  });\n  return jsMapView.map;\n}\n\nfunction MyMapComponent() {\n  const ref = useRef();\n\n  useEffect(() => {\n    const urlZoom = getQueryStringValue(\"zoom\");\n    const urlCenter = getQueryStringValue(\"center\");\n    map = initializeMapObject(ref.current);\n    mapLoadedResolver();\n    const vehicleBounds = addTripPolys(map);\n    if (urlZoom && urlCenter) {\n      console.log(\"setting zoom & center from url\", urlZoom, urlCenter);\n      map.setZoom(parseInt(urlZoom));\n      map.setCenter(JSON.parse(urlCenter));\n    } else {\n      map.fitBounds(vehicleBounds);\n    }\n    map.addListener(\"zoom_changed\", () => {\n      setQueryStringValue(\"zoom\", map.getZoom());\n    });\n\n    map.addListener(\n      \"center_changed\",\n      _.debounce(() => {\n        setQueryStringValue(\"center\", JSON.stringify(map.getCenter().toJSON()));\n      }, 100)\n    );\n  });\n\n  return <div ref={ref} id=\"map\" style={{ height: \"500px\" }} />;\n}\n\nfunction getPolyBounds(bounds, p) {\n  p.getPath().forEach((e) => {\n    bounds.extend(e);\n  });\n  return bounds;\n}\n\n/*\n * Deterministically assign a color per trip using tripIdx\n * Colors were chosen for visibility\n */\nfunction getColor(tripIdx) {\n  const colors = [\n    \"#2d7dd2\",\n    \"#97cc04\",\n    \"#eeb902\",\n    \"#f45d01\",\n    \"#474647\",\n    \"00aa00\",\n  ];\n  return colors[tripIdx % colors.length];\n}\n\nfunction Map(props) {\n  tripLogs = props.logData.tripLogs;\n  minDate = tripLogs.minDate.getTime();\n  maxDate = tripLogs.maxDate.getTime();\n  const urlParams = new URLSearchParams(window.location.search);\n  apikey = urlParams.get(\"apikey\") || props.logData.apikey;\n  jwt = props.logData.jwt;\n  projectId = props.logData.projectId;\n  solutionType = props.logData.solutionType;\n\n  return (\n    <Wrapper\n      apiKey={apikey}\n      render={render}\n      version=\"beta\"\n      libraries={[\"geometry\", \"journeySharing\"]}\n    >\n      <MyMapComponent />\n    </Wrapper>\n  );\n}\n\n/*\n * Handler for timewindow change.  Updates global min/max date globals\n * and recomputes the paths as well as all the bubble markers to respect the\n * new date values.\n *\n * Debounced to every 100ms as a blance between performance and reactivity when\n * the slider is dragged.\n */\nconst onSliderChangeMap = _.debounce((rangeStart, rangeEnd) => {\n  minDate = new Date(rangeStart);\n  maxDate = new Date(rangeEnd);\n  addTripPolys(map);\n  _.forEach(toggleHandlers, (handler, name) => {\n    if (bubbleMap[name]) {\n      handler(true);\n    }\n  });\n}, 100);\n\nfunction addMarkersToMapForData(data) {\n  _.forEach(dataMakers, (m) => m.setMap(null));\n  dataMakers = [];\n  const svgMarker = {\n    path: \"M10.453 14.016l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM12 2.016q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z\",\n    fillColor: \"blue\",\n    fillOpacity: 0.6,\n    strokeWeight: 0,\n    rotation: 0,\n    scale: 2,\n    anchor: new google.maps.Point(15, 30),\n  };\n\n  const rawLocation = _.get(\n    data,\n    \"jsonPayload.request.vehicle.lastLocation.rawLocation\"\n  );\n  if (rawLocation) {\n    const status = _.get(data, \"jsonPayload.response.status\");\n    const state = _.get(data, \"jsonPayload.response.state\");\n    const locationForLog = new window.google.maps.Marker({\n      position: { lat: rawLocation.latitude, lng: rawLocation.longitude },\n      map: map,\n      icon: svgMarker,\n      title: \"Vehicle state \" + state + \" Trip Status \" + status,\n    });\n    dataMakers.push(locationForLog);\n  }\n  // TODO: for non-vehicle api calls could attempt to interpolate the location\n}\n\n/*\n * GenerateBubbles() -- helper function for generating map features based\n * on per-log entry data.\n *\n * Handles the gunk of iterating over log entries and clearing/setting the map\n */\nfunction GenerateBubbles(bubbleName, cb) {\n  return (showBubble) => {\n    _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n    delete bubbleMap[bubbleName];\n    if (showBubble) {\n      bubbleMap[bubbleName] = tripLogs\n        .getLogs_(minDate, maxDate)\n        .map((le) => {\n          const lastLocation = _.get(\n            le,\n            \"jsonPayload.request.vehicle.lastLocation\"\n          );\n          let rawLocation;\n          let bubble = undefined;\n          if (lastLocation && (rawLocation = lastLocation.rawLocation)) {\n            bubble = cb(\n              new google.maps.LatLng({\n                lat: rawLocation.latitude,\n                lng: rawLocation.longitude,\n              }),\n              lastLocation,\n              le\n            );\n          }\n          return bubble;\n        })\n        .compact()\n        .value();\n    }\n  };\n}\n\n/*\n * Draws circles on map with a radius equal to the\n * GPS accuracy.\n */\ntoggleHandlers[\"showGPSBubbles\"] = GenerateBubbles(\n  \"showGPSBubbles\",\n  (rawLocationLatLng, lastLocation) => {\n    let color;\n    switch (lastLocation.locSensor) {\n      case \"LOCATION_SENSOR_GPS\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_NETWORK\":\n        color = \"#FF1111\";\n        break;\n      case \"LOCATION_SENSOR_PASSIVE\":\n        color = \"#FF0000\";\n        break;\n      case \"LOCATION_SENSOR_ROAD_SNAPPED_LOCATION_PROVIDER\":\n        color = \"#00FF00\";\n        break;\n      case \"LOCATION_SENSOR_FUSED_LOCATION_PROVIDER\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_LOG_UNSPECIFIED\":\n      default:\n        color = \"#000000\";\n    }\n    const accuracy = lastLocation.rawLocationAccuracy;\n    if (accuracy) {\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: accuracy, // units is this actually meters?\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          rawLocationAccuracy: lastLocation.rawLocationAccuracy,\n          locSensor: lastLocation.locSensor,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws circles on map with a radius equal to the\n * time delta (1 meter radius = 1 second of delta)\n */\ntoggleHandlers[\"showClientServerTimeDeltas\"] = GenerateBubbles(\n  \"showClientServerTimeDeltas\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    const clientTimeStr = _.get(\n      logEntry,\n      \"jsonPayload.response.lastLocation.rawLocationTime\"\n    );\n    const serverTimeStr = _.get(\n      logEntry,\n      \"jsonPayload.response.lastLocation.serverTime\"\n    );\n    if (clientTimeStr && serverTimeStr) {\n      const clientDate = new Date(clientTimeStr);\n      const serverDate = new Date(serverTimeStr);\n      const timeDeltaSeconds =\n        Math.abs(clientDate.getTime() - serverDate.getTime()) / 1000;\n      let color;\n      if (clientDate > serverDate) {\n        color = \"#0000F0\";\n      } else {\n        color = \"#0F0000\";\n      }\n\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: timeDeltaSeconds,\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          timeDeltaSeconds: timeDeltaSeconds,\n          serverDate: serverDate,\n          clientDate: clientDate,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws arrows on map showing the measured heading\n * of the vehicle (ie which direction vehicle was traveling\n */\ntoggleHandlers[\"showHeading\"] = GenerateBubbles(\n  \"showHeading\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    // Note: Heading & accuracy are only on the _request_ not the\n    // response.\n    const heading = _.get(\n      logEntry,\n      \"jsonPayload.request.vehicle.lastLocation.heading\"\n    );\n    const accuracy = _.get(\n      logEntry,\n      \"jsonPayload.request.vehicle.lastLocation.bearingAccuracy\"\n    );\n\n    // Not currently using accuracy. How to show it?  Maybe opacity of the arrorw?\n    const arrowLength = 20; // meters??\n    if (!(heading && accuracy)) {\n      return;\n    }\n    const headingLine = new google.maps.Polyline({\n      strokeColor: \"#0000F0\",\n      strokeOpacity: 0.6,\n      strokeWeight: 2,\n      icons: [\n        {\n          icon: {\n            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n            strokeColor: \"#0000FF\",\n            strokeWeight: 4,\n          },\n          offset: \"100%\",\n        },\n      ],\n      map,\n      path: [\n        rawLocationLatLng,\n        google.maps.geometry.spherical.computeOffset(\n          rawLocationLatLng,\n          arrowLength,\n          heading\n        ),\n      ],\n    });\n    google.maps.event.addListener(headingLine, \"click\", () => {\n      // TODO: allow updating panorama based on forward/back\n      // stepper buttons (ie at each updatevehicle log we have a heading)\n      panorama = new google.maps.StreetViewPanorama(\n        document.getElementById(\"map\"),\n        {\n          position: rawLocationLatLng,\n          pov: { heading: heading, pitch: 10 },\n          addressControlOptions: {\n            position: google.maps.ControlPosition.BOTTOM_CENTER,\n          },\n          linksControl: false,\n          panControl: false,\n          enableCloseButton: true,\n        }\n      );\n      console.log(\"loaded panorama\", panorama);\n    });\n    return headingLine;\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates vehicle speed at that\n * location.\n */\ntoggleHandlers[\"showSpeed\"] = GenerateBubbles(\n  \"showSpeed\",\n  (rawLocationLatLng, lastLocation) => {\n    const speed = lastLocation.speed;\n    if (lastLocation.speed === undefined) {\n      return;\n    }\n    const color = speed < 0 ? \"#FF0000\" : \"#00FF00\";\n    return new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: Math.abs(speed),\n    });\n  }\n);\n\n/*\n * Enable/disables live traffic layer\n */\ntoggleHandlers[\"showTraffic\"] = function (enabled) {\n  if (!trafficLayer) {\n    trafficLayer = new google.maps.TrafficLayer();\n  }\n  if (enabled) {\n    trafficLayer.setMap(map);\n  } else {\n    trafficLayer.setMap(null);\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showDwellLocations\"] = function (enabled) {\n  const bubbleName = \"showDwellLocations\";\n  const dwellLocations = tripLogs.getDwellLocations(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(dwellLocations, (dl) => {\n      return new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"#FFFF00\",\n        fillOpacity: 0.25,\n        map,\n        center: dl.leaderCoords,\n        radius: dl.updates * 3, // make dwell times more obvious\n      });\n    });\n  }\n};\n\n/*\n * Draws arrows on the map showing where a vehicle jumped\n * from one location to another at an unrealistic velocity.\n */\ntoggleHandlers[\"showHighVelocityJumps\"] = function (enabled) {\n  const bubbleName = \"showHighVelocityJumps\";\n  const jumps = tripLogs.getHighVelocityJumps(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(jumps)\n      .map((jump) => {\n        function getStrokeWeight(velocity) {\n          if (velocity <= 100) {\n            return 2;\n          } else if (velocity < 1000) {\n            return 6;\n          } else if (velocity < 2000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const path = new window.google.maps.Polyline({\n          path: [jump.startLoc, jump.endLoc],\n          geodesic: true,\n          strokeColor: getColor(jump.jumpIdx),\n          strokeOpacity: 0.8,\n          strokeWeight: getStrokeWeight(jump.velocity),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: getColor(jump.jumpIdx),\n                strokeWeight: getStrokeWeight(jump.velocity),\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n          // show a minute +/- on each side of a jump\n          setTimeRange(\n            jump.startDate.getTime() - 60 * 1000,\n            jump.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Marks locations on the map where we did not get the expected\n * updateVehicle requests\n */\ntoggleHandlers[\"showMissingUpdates\"] = function (enabled) {\n  const bubbleName = \"showMissingUpdates\";\n  const missingUpdates = tripLogs.getMissingUpdates(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(missingUpdates)\n      .map((update) => {\n        function getStrokeWeight(interval) {\n          if (interval <= 60 * 1000) {\n            return 2;\n          } else if (interval < 60 * 10 * 1000) {\n            return 6;\n          } else if (interval < 60 * 60 * 10 * 1000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const heading = google.maps.geometry.spherical.computeHeading(\n          update.startLoc,\n          update.endLoc\n        );\n        const offsetHeading = ((heading + 360 + 90) % 360) - 180;\n        const points = [\n          update.startLoc,\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          update.endLoc,\n        ];\n        const path = new window.google.maps.Polyline({\n          path: points,\n          geodesic: true,\n          strokeColor: \"#008B8B\",\n          strokeOpacity: 0.5,\n          strokeWeight: getStrokeWeight(update.interval),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: \"#008B8B\",\n                strokeWeight: getStrokeWeight(update.interval),\n                scale: 6,\n              },\n              offset: \"50%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"0%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          path.setOptions({\n            strokeOpacity: 1,\n            strokeWeight: 1.5 * getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"mouseout\", () => {\n          path.setOptions({\n            strokeOpacity: 0.5,\n            strokeWeight: getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          // show a minute +/- on each side of a update\n          setTimeRange(\n            update.startDate.getTime() - 60 * 1000,\n            update.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Enable/disables live journey sharing view\n */\ntoggleHandlers[\"showLiveJS\"] = function (enabled) {\n  if (!jwt) {\n    console.log(\"Issue #25 -- no/invalid jwt\");\n    return;\n  }\n  // call into js to set the trip\n  if (enabled) {\n    locationProvider.tripId = _.last(tripLogs.getTripIDs());\n  } else {\n    locationProvider.tripId = \"\";\n  }\n};\n\nfunction updateMapToggles(toggleName, enabled) {\n  toggleHandlers[toggleName](enabled);\n}\n\n/*\n * Register handlers that allow this code to call\n * into react components.  (ie display trip data\n * in the object viewer component when a vehicle track\n * polyline  is clicked on).\n */\nfunction registerHandlers(featureObject, timeRange) {\n  setFeaturedObject = featureObject;\n  setTimeRange = timeRange;\n}\n\nexport {\n  Map as default,\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n  mapLoadPromise,\n};\n","import qs from \"query-string\";\n\nconst setQueryStringWithoutPageReload = (qsValue) => {\n  const newurl =\n    window.location.protocol +\n    \"//\" +\n    window.location.host +\n    window.location.pathname +\n    qsValue;\n  window.history.pushState({ path: newurl }, \"\", newurl);\n};\n\nexport const getQueryStringValue = (\n  key,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  return values[key];\n};\n\nexport const setQueryStringValue = (\n  key,\n  value,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  const newQsValue = qs.stringify({\n    ...values,\n    [key]: value,\n  });\n  setQueryStringWithoutPageReload(`?${newQsValue}`);\n};\n","/*\n * Dataframe.js\n *\n * JSON viewer for log entries.   Clicking on a property _value_\n * adds it to the log viewer.\n *\n * TODO: support clicking on the property name as well, or support an\n * icon or other UI element (similar to copy to clip board).\n */\nimport ReactJson from \"react-json-view\";\nfunction Dataframe(props) {\n  return <ReactJson src={props.featuredObject} onSelect={props.onClick} />;\n}\n\n// TODO: Ideas: allow selecting a field and see how it changes along the map\n// or the slider (ie view on map / view on slider)\n// or 'add slider' that instantiates a slider that has marks\n// when that value changes\nexport default Dataframe;\n","/*\n * TimeSlider.js\n *\n * Provides a time-based visualaziton of key events (vehicle status changes) as well\n * as filtering control for the log viewer & map view.\n *\n * TODO: not clear that rc-slider is actually the correct/best component for this\n * functionality\n */\nimport Slider from \"rc-slider\";\nimport \"rc-slider/assets/index.css\";\nimport _ from \"lodash\";\n\nconst { createSliderWithTooltip } = Slider;\nconst Range = createSliderWithTooltip(Slider.Range);\n\nconst style = { width: \"100%\" };\n\nfunction TimeSlider(props) {\n  const tripLogs = props.logData.tripLogs;\n  const marks = {};\n\n  // Add marks showing when trip status changed.\n  // Ideally label by trip status change ... but labels overrun & look ugly\n  _.map(tripLogs.getTripStatusChanges(), (change) => {\n    marks[change.date.getTime()] = {};\n  });\n\n  const minVal = tripLogs.minDate.getTime();\n  const maxVal = tripLogs.maxDate.getTime();\n\n  const curMin = _.max([minVal, props.curMin]);\n  const curMax = _.min([maxVal, props.curMax]);\n\n  function onChange(value) {\n    props.onSliderChange({\n      minTime: value[0],\n      maxTime: value[1],\n    });\n  }\n\n  function formatTooltip(value) {\n    const d = new Date(value);\n    const tripStatus = tripLogs.getTripStatusAtDate(new Date(value));\n    return `${d}${tripStatus}`;\n  }\n\n  return (\n    <div style={style}>\n      <Range\n        min={minVal}\n        max={maxVal}\n        marks={marks}\n        step={1}\n        onChange={onChange}\n        defaultValue={[minVal, maxVal]}\n        value={[curMin, curMax]}\n        tipFormatter={formatTooltip}\n      />\n    </div>\n  );\n}\n\nexport default TimeSlider;\n","/*\n * LogTable.js\n *\n * Handles the log viewing component.\n */\nimport { useTable } from \"react-table\";\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\n\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n  }\n`;\n\nfunction Table({ columns, data, onSelectionChange }) {\n  const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } =\n    useTable({\n      columns,\n      data,\n    });\n\n  return (\n    <table {...getTableProps()}>\n      <thead>\n        {headerGroups.map((headerGroup) => (\n          <tr {...headerGroup.getHeaderGroupProps()}>\n            {headerGroup.headers.map((column) => (\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\n            ))}\n          </tr>\n        ))}\n      </thead>\n      <tbody {...getTableBodyProps()}>\n        {rows.map((row) => {\n          prepareRow(row);\n          return (\n            <tr\n              {...row.getRowProps()}\n              onClick={() => onSelectionChange(row.original)}\n            >\n              {row.cells.map((cell) => {\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\n              })}\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\n/*\n * Helper method for removing common substrings in cells.  Typically\n * used for removing a prefix from ENUMs.\n */\nconst TrimCell = ({ value, trim }) => {\n  return <>{value && value.replace(trim, \"\")}</>;\n};\n\nfunction LogTable(props) {\n  const minTime = props.timeRange.minTime;\n  const maxTime = props.timeRange.maxTime;\n  const data = props.logData.tripLogs\n    .getLogs_(new Date(minTime), new Date(maxTime))\n    .value();\n\n  const columns = React.useMemo(() => {\n    const stdColumns = [\n      {\n        Header: \"Date\",\n        accessor: \"formattedDate\",\n      },\n      {\n        Header: \"SDK Version\",\n        accessor: \"jsonPayload.request.header.sdkVersion\",\n      },\n      {\n        Header: \"OS Version\",\n        accessor: \"jsonPayload.request.header.osVersion\",\n      },\n      {\n        Header: \"Method\",\n        accessor: \"jsonPayload.@type\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell\n            value={value}\n            trim=\"type.googleapis.com/maps.fleetengine.\"\n          />\n        ),\n      },\n      {\n        Header: \"Vehicle\",\n        accessor: \"labels.vehicle_id\",\n      },\n      {\n        Header: \"Trip\",\n        accessor: \"labels.trip_id\",\n      },\n      {\n        Header: \"Vehicle State\",\n        accessor: \"jsonPayload.response.state\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"VEHICLE_STATE_\" />\n        ),\n      },\n      {\n        Header: \"Trip Status\",\n        accessor: \"jsonPayload.response.status\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"TRIP_STATUS_\" />\n        ),\n      },\n      {\n        Header: \"Nav Status\",\n        accessor: \"jsonPayload.response.navStatus\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"NAVIGATION_STATUS_\" />\n        ),\n      },\n    ];\n\n    // Add dynamic columns\n    _.map(props.extraColumns, (dotPath) => {\n      const elems = dotPath.split(\".\");\n      stdColumns.push({\n        Header: elems[elems.length - 1],\n        accessor: dotPath,\n      });\n    });\n    const headers = [\n      {\n        Header: \"Log Entries (click row to view full log entry)\",\n        columns: stdColumns,\n      },\n    ];\n    return headers;\n  }, [props.extraColumns]);\n\n  return (\n    <Styles>\n      <Table\n        columns={columns}\n        data={data}\n        onSelectionChange={props.onSelectionChange}\n      />\n    </Styles>\n  );\n}\n\nexport { LogTable as default };\n","/*\n * ToggleBar.js\n *\n * Row of buttons that configure visualization options on the map\n */\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\nconst Button = styled.button``;\nconst ButtonToggle = styled(Button)`\n  opacity: 0.6;\n  ${({ active }) =>\n    active &&\n    `\n    opacity: 1;\n    color: Green;\n  `}\n`;\n\nconst ButtonGroup = styled.div`\n  display: flex;\n`;\nfunction ToggleBar(props) {\n  const toggleState = props.toggleState;\n  const toggles = _.map(props.toggles, (toggle) => {\n    return (\n      <ButtonToggle\n        key={toggle.id}\n        active={toggleState[toggle.id]}\n        onClick={() => props.clickHandler(toggle.id)}\n      >\n        {toggle.name}\n        <a href={toggle.docLink} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n    );\n  });\n  return <ButtonGroup>{toggles}</ButtonGroup>;\n}\n\nexport default ToggleBar;\n","/*\n * App.js\n *\n * Basic react app container.  Handles state for the app and\n * propagation for state changes into the non-react map\n */\nimport React from \"react\";\nimport {\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n  mapLoadPromise,\n} from \"./Map\";\nimport Dataframe from \"./Dataframe\";\nimport TimeSlider from \"./TimeSlider\";\nimport LogTable from \"./LogTable\";\nimport ToggleBar from \"./ToggleBar\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\n\n/**\n * returns the default value for the button from the url\n */\nfunction getToggleDefault(urlKey, defaultVal) {\n  const urlVal = getQueryStringValue(urlKey);\n  if (urlVal === \"true\") {\n    defaultVal = true;\n  }\n  return defaultVal;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    const nowDate = new Date();\n    let urlMinTime = getQueryStringValue(\"minTime\");\n    let urlMaxTime = getQueryStringValue(\"maxTime\");\n    this.initialMinTime = urlMinTime ? parseInt(urlMinTime) : 0;\n    // default max time to 1 year in the future\n    this.initialMaxTime = urlMaxTime\n      ? parseInt(urlMaxTime)\n      : nowDate.setFullYear(nowDate.getFullYear() + 1);\n\n    this.logData = props.logData;\n    this.state = {\n      timeRange: {\n        minTime: this.initialMinTime,\n        maxTime: this.initialMaxTime,\n      },\n      featuredObject: { msg: \"Click a table row to select object\" },\n      extraColumns: [],\n      toggleOptions: {\n        showGPSBubbles: getToggleDefault(\"showGPSBubbles\", false),\n        showHeading: getToggleDefault(\"showHeading\", false),\n        showSpeed: getToggleDefault(\"showSpeed\", false),\n        showTraffic: getToggleDefault(\"showTraffic\", false),\n        showDwellLocations: getToggleDefault(\"showDwellLocations\", false),\n        showHighVelocityJumps: getToggleDefault(\"showHighVelocityJumps\", false),\n        showMissingUpdates: getToggleDefault(\"showMissingUpdates\", false),\n        showLiveJS: getToggleDefault(\"showLiveJS\", false),\n        showClientServerTimeDeltas: getToggleDefault(\n          \"showClientServerTimeDeltas\",\n          false\n        ),\n      },\n    };\n    // Realtime updates are too heavy.  There must be a better/ react way\n    this.onSliderChangeDebounced = _.debounce(\n      (timeRange) => this.onSliderChange(timeRange),\n      25\n    );\n\n    // Allow map code to set which object is featured, and\n    // adjust the timerange filtering\n    registerHandlers(\n      (fo) => this.setFeaturedObject(fo),\n      (minTime, maxTime) => this.setTimeRange(minTime, maxTime)\n    );\n    // TODO: refactor so that visualizations are registered\n    // rather than enumerated here?\n    this.toggles = [\n      {\n        id: \"showGPSBubbles\",\n        name: \"GPS Accuracy\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/GPSAccuracy.md\",\n        columns: [\n          \"jsonPayload.request.vehicle.lastLocation.rawLocationAccuracy\",\n          \"jsonPayload.request.vehicle.lastLocation.locSensor\",\n        ],\n      },\n      {\n        id: \"showHeading\",\n        name: \"Heading\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Heading.md\",\n        columns: [\n          \"jsonPayload.request.vehicle.lastLocation.heading\",\n          \"jsonPayload.request.vehicle.lastLocation.bearingAccuracy\",\n        ],\n      },\n      {\n        id: \"showSpeed\",\n        name: \"Speed\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Speed.md\",\n        columns: [\"jsonPayload.request.vehicle.lastLocation.speed\"],\n      },\n      {\n        id: \"showDwellLocations\",\n        name: \"Dwell Locations\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/DwellTimes.md\",\n        columns: [],\n      },\n      {\n        id: \"showHighVelocityJumps\",\n        name: \"Jumps (unrealistic velocity)\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/VelocityJumps.md\",\n        columns: [\"jsonPayload.request.vehicle.lastLocation.speed\"],\n      },\n      {\n        id: \"showMissingUpdates\",\n        name: \"Jumps (Temporal)\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/MissingUpdates.md\",\n        columns: [\"jsonPayload.temporal_gap\"],\n      },\n      {\n        id: \"showClientServerTimeDeltas\",\n        name: \"Client/Server Time Deltas\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n        columns: [\n          \"jsonPayload.response.lastLocation.rawLocationTime\",\n          \"jsonPayload.response.lastLocation.serverTime\",\n        ],\n      },\n      {\n        id: \"showTraffic\",\n        name: \"Traffic\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n        columns: [],\n      },\n      {\n        id: \"showLiveJS\",\n        name: \"Start Live Journey Sharing for newest trip\",\n        docLink:\n          \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n        columns: [],\n      },\n    ];\n  }\n\n  /*\n   * Update react state from data in the url.  This could/should be\n   * cleaned up.  The pure react state is actually set properly in the\n   * constructor ... all this does is update the map and associated\n   * data (once it's loaded).  Given this split it's definitely possible\n   * that this just overwrites settings a quickfingered user already\n   * changed.\n   */\n  componentDidMount() {\n    mapLoadPromise.then(() => {\n      this.setTimeRange(this.initialMinTime, this.initialMaxTime);\n      _.map(this.toggles, (toggle) => {\n        const urlVal = getQueryStringValue(toggle.id);\n        if (urlVal === \"true\") {\n          this.updateToggleState(true, toggle.id, toggle.columns);\n        }\n      });\n    });\n  }\n\n  updateToggleState(newValue, toggleName, jsonPaths) {\n    this.setState((prevState) => {\n      prevState.toggleOptions[toggleName] = newValue;\n      updateMapToggles(toggleName, newValue);\n      setQueryStringValue(toggleName, newValue);\n\n      const extraColumns = _.clone(prevState.extraColumns);\n      _.forEach(jsonPaths, (path) => {\n        if (newValue) {\n          extraColumns.push(path);\n        } else {\n          _.pull(extraColumns, path);\n        }\n      });\n      prevState.extraColumns = _.uniq(extraColumns);\n\n      return prevState;\n    });\n  }\n\n  /*\n   * Updates react state associated with the slider and calls into\n   * the non-react map code to do the same.\n   */\n  onSliderChange(timeRange) {\n    this.setTimeRange(timeRange.minTime, timeRange.maxTime);\n  }\n\n  /*\n   * Callback to updated selected log row\n   */\n  onSelectionChange(selectedRow) {\n    addMarkersToMapForData(selectedRow);\n    this.setFeaturedObject(selectedRow);\n  }\n\n  /*\n   * Set the featured object\n   */\n  setFeaturedObject(featuredObject) {\n    this.setState({ featuredObject: featuredObject });\n  }\n\n  /*\n   * exposes editing of the timeRange state\n   */\n  setTimeRange(minTime, maxTime) {\n    setQueryStringValue(\"minTime\", minTime);\n    setQueryStringValue(\"maxTime\", maxTime);\n    this.setState({\n      timeRange: {\n        minTime: minTime,\n        maxTime: maxTime,\n      },\n    });\n\n    // Handle Map component separately from standard state update\n    onSliderChangeMap(minTime, maxTime);\n  }\n\n  /*\n   * Callback to handle clicks on properties in the json viewer.\n   * Adds/removes row from the log viewer based on which property\n   * in the json object was clicked on\n   */\n  onDataframePropClick(select) {\n    this.setState((prevState) => {\n      const jsonPath = _.join(select.namespace, \".\") + \".\" + select.name;\n      let newColumns;\n      if (_.find(prevState.extraColumns, (x) => x === jsonPath)) {\n        newColumns = _.without(prevState.extraColumns, jsonPath);\n      } else {\n        newColumns = [...prevState.extraColumns, jsonPath];\n      }\n      return {\n        extraColumns: newColumns,\n      };\n    });\n  }\n\n  toggleClickHandler(id) {\n    const toggle = _.find(this.toggles, { id });\n    const newValue = !this.state.toggleOptions[id];\n    this.updateToggleState(newValue, id, toggle.columns);\n  }\n\n  render() {\n    return (\n      <div>\n        <TimeSlider\n          logData={this.logData}\n          curMin={this.state.timeRange.minTime}\n          curMax={this.state.timeRange.maxTime}\n          onSliderChange={this.onSliderChangeDebounced}\n        />\n        <ToggleBar\n          toggles={this.toggles}\n          toggleState={this.state.toggleOptions}\n          clickHandler={(id) => this.toggleClickHandler(id)}\n        />\n        <div style={{ width: \"100%\", marginTop: \"20px\" }}>\n          <div\n            style={{\n              width: \"65%\",\n              overflowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n              float: \"left\",\n            }}\n          >\n            <LogTable\n              logData={this.logData}\n              style={{ width: \"100%\" }}\n              timeRange={this.state.timeRange}\n              extraColumns={this.state.extraColumns}\n              onSelectionChange={(featuredObject) =>\n                this.onSelectionChange(featuredObject)\n              }\n            />\n          </div>\n          <div\n            style={{\n              marginLeft: \"65%\",\n              overFlowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n            }}\n          >\n            <Dataframe\n              featuredObject={this.state.featuredObject}\n              onClick={(select) => this.onDataframePropClick(select)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { App as default };\n","/*\n * vehicleData.js\n *\n * Load raw log data for easier consumption by other components.\n */\nimport TripLogs from \"./TripLogs\";\nlet jwt;\nlet projectId;\nlet apikey;\nlet solutionType;\nlet tripLogs;\n\n/**\n * This function must be called (and awaited on) to load the raw data before\n * any of the other exported fields are accessed.\n */\nasync function loadData() {\n  const response = await fetch(\"./data.json\");\n  const parsedData = await response.json();\n  jwt = parsedData.jwt;\n  projectId = parsedData.projectId;\n  apikey = parsedData.APIKEY;\n  solutionType = parsedData.solutionType;\n  tripLogs = new TripLogs(parsedData.rawLogs, solutionType);\n}\n\nexport { loadData, tripLogs, apikey, jwt, projectId, solutionType };\n","class Utils {\n  /*\n   * Formats a duration into something friendly\n   * for human consumption.\n   */\n  static formatDuration(duration) {\n    let sec_num = duration / 1000;\n    let hours = Math.floor(sec_num / 3600);\n    let minutes = Math.floor((sec_num - hours * 3600) / 60);\n    let seconds = Math.floor(sec_num - hours * 3600 - minutes * 60);\n    let timeStr = \"\";\n\n    if (hours > 0) {\n      timeStr += hours + \" hours \";\n    }\n    if (minutes > 0) {\n      timeStr += minutes + \" minutes \";\n    }\n    if (seconds > 0) {\n      timeStr += seconds + \" seconds\";\n    }\n    return timeStr;\n  }\n}\nexport { Utils as default };\n","/*\n * Trip.js\n *\n * Processed log for a trip. Currently only includes very basic information\n * about the trip\n */\nimport _ from \"lodash\";\nimport Utils from \"./Utils\";\n\nclass Trip {\n  constructor(tripIdx, tripName, firstUpdate) {\n    this.tripIdx = tripIdx;\n    this.tripName = tripName;\n    this.updateRequests = 1;\n    this.pathCoords = [];\n    this.tripDuration = 0;\n    this.creationTime = \"Unknown\";\n    this.firstUpdate = firstUpdate;\n    this.lastUpdate = \"Unknown\";\n  }\n\n  getTraveledDistance() {\n    return window.google.maps.geometry.spherical.computeLength(this.pathCoords);\n  }\n\n  /*\n   * Returns data about trip to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      updateRequests: this.updateRequests,\n      tripName: this.tripName,\n      duration: Utils.formatDuration(this.tripDuration),\n      creationTime: this.creationTime,\n      traveledDistanceKilometers: this.getTraveledDistance() / 1000,\n      traveledDistanceMiles: this.getTraveledDistance() / 1609,\n      firstUpdate: this.firstUpdate,\n      lastUpdate: this.lastUpdate,\n    };\n  }\n\n  getPathCoords(minDate, maxDate) {\n    if (!(minDate && maxDate)) {\n      return this.pathCoords;\n    }\n    return _(this.pathCoords)\n      .filter((le) => {\n        return le.date >= minDate && le.date <= maxDate;\n      })\n      .value();\n  }\n\n  // append full raw log? would make downstream processing easier\n  // or synthesize pathCoords on the fly?\n  appendCoords(lastLocation, timestamp) {\n    this.pathCoords.push({\n      lat: lastLocation.rawLocation.latitude,\n      lng: lastLocation.rawLocation.longitude,\n      trip_id: this.tripName,\n      date: new Date(timestamp),\n    });\n  }\n}\nexport { Trip as default };\n","/*\n * stats helpers\n */\nclass Stats {\n  static median(dataSet) {\n    if (dataSet.length === 1) return dataSet[0];\n    const sorted = [...dataSet].sort();\n    const ceil = Math.ceil(sorted.length / 2);\n    const floor = Math.floor(sorted.length / 2);\n    if (ceil === floor) return sorted[floor];\n    return (sorted[ceil] + sorted[floor]) / 2;\n  }\n}\nexport { Stats as default };\n","/*\n * HighVelocityJump.js\n *\n * Representation of a HighVelocityJump\n */\nimport _ from \"lodash\";\nconst velocityOutlier = 68; // true velocities higher than this unlikely (in Meters/sec aprrox 150 MPH)\nimport Stats from \"./Stats\";\nlet computedOutlier = 0;\n\nclass HighVelocityJump {\n  constructor(jumpIdx, prevEntry, curEntry) {\n    const prevLoc = _.get(\n      prevEntry,\n      \"jsonPayload.request.vehicle.lastLocation\"\n    );\n    const curLoc = _.get(curEntry, \"jsonPayload.request.vehicle.lastLocation\");\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    const distanceTraveled =\n      window.google.maps.geometry.spherical.computeDistanceBetween(\n        startLoc,\n        endLoc\n      );\n    const timeSpentMS = curEntry.date - prevEntry.date;\n    const velocity = distanceTraveled / (timeSpentMS / 1000.0);\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.timeSpentMS = timeSpentMS;\n    this.distanceTraveled = distanceTraveled;\n    this.velocity = velocity;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.jumpIdx = jumpIdx;\n  }\n\n  /*\n   * Returns data about the jump to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      timeSpentMS: this.timeSpentMS,\n      distanceTraveled: this.distanceTraveled,\n      velocity: this.velocity,\n      velocityMPH: this.velocity * 2.237,\n      startLoc: this.startLoc.toString(),\n      startDate: this.prevEntry.date,\n      endDate: this.entry.date,\n      endLoc: this.endLoc.toString(),\n      jumpIdx: this.jumpIdx,\n      date: this.entry.date,\n      computedOutlierVelocity: computedOutlier,\n    };\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Jump\",\n      request: {\n        vehicle: {\n          lastLocation: {\n            speed: this.velocity,\n          },\n        },\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters jumps down to instances where the vehicle was\n   * travelling at an unrealistic speed (either\n   * greater that 150 MPH, or 100x median velocity).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantJumps(jumps) {\n    if (!jumps) {\n      return [];\n    }\n    const velocities = _.map(jumps, \"velocity\");\n    const avgVelocity = _.mean(velocities);\n    const medianVelocity = Stats.median(velocities);\n    const minVelocity = _.min(velocities);\n    const maxVelocity = _.max(velocities);\n    console.log(\"avgVelocity\", avgVelocity);\n    console.log(\"medianVelocity\", medianVelocity);\n    console.log(\"minVelocity\", minVelocity);\n    console.log(\"maxVelocity\", maxVelocity);\n    computedOutlier = _.min([velocityOutlier, medianVelocity * 100]);\n    return _(jumps)\n      .filter((e) => e.velocity >= computedOutlier)\n      .sortBy(\"velocity\")\n      .value();\n  }\n}\nexport { HighVelocityJump as default };\n","/*\n * MissingUpdate.js\n *\n * Representation of a missing update\n */\nimport _ from \"lodash\";\nconst updateOutlier = 60000; // 60 seconds\nimport Stats from \"./Stats\";\nimport Utils from \"./Utils\";\nlet computedOutlier = 0;\n\nclass MissingUpdate {\n  constructor(idx, prevEntry, curEntry) {\n    const interval = curEntry.date - prevEntry.date;\n    const curLoc = _.get(curEntry, \"jsonPayload.request.vehicle.lastLocation\");\n    const prevLoc = _.get(\n      prevEntry,\n      \"jsonPayload.request.vehicle.lastLocation\"\n    );\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.interval = interval;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.idx = idx;\n    this.startVehicleState = _.get(curEntry, \"jsonPayload.response.state\");\n    this.endVehicleState = _.get(prevEntry, \"jsonPayload.response.state\");\n    this.duration = Utils.formatDuration(this.interval);\n  }\n\n  /*\n   * Returns data about the update to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      duration: this.duration,\n      interval: this.interval,\n      startDate: this.startDate,\n      startLoc: this.startLoc.toString(),\n      endDate: this.endDate,\n      endLoc: this.endLoc.toString(),\n      startVehicleState: this.startVehicleState,\n      endVehicleState: this.endVehicleState,\n      computedOutlier: Utils.formatDuration(computedOutlier),\n    };\n  }\n\n  /*\n   * format a vehicle state transitino into something a\n   * human can easily read.\n   */\n  getStateTransition() {\n    const start = this.startVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    const end = this.endVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    return start + \">\" + end;\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.date = this.startDate;\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Missing Updates\",\n      temporal_gap: featureData.duration,\n      response: {\n        state: this.getStateTransition(),\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters updates down to instances where now updates\n   * were received from the vehicle for either 60 seconds\n   * or 10x the median observed update (our default\n   * update is every 5 seconds).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantMissingUpdates(updates) {\n    if (!updates) {\n      return [];\n    }\n    const intervals = _.map(updates, \"interval\");\n    const avgInternal = _.mean(intervals);\n    const medianInternal = Stats.median(intervals);\n    const minInternal = _.min(intervals);\n    const maxInternal = _.max(intervals);\n    console.log(\"avgInternal\", avgInternal);\n    console.log(\"medianInternal\", medianInternal);\n    console.log(\"minInternal\", minInternal);\n    console.log(\"maxInternal\", maxInternal);\n    console.log(\"updateOutlier\", updateOutlier);\n    computedOutlier = _.min([medianInternal * 10, updateOutlier]);\n    console.log(\"computedOutlier\", computedOutlier);\n    return _(updates)\n      .filter((e) => e.interval >= computedOutlier)\n      .sortBy(\"interval\")\n      .value();\n  }\n}\nexport { MissingUpdate as default };\n","/*\n * TripLogs.js\n *\n * Processes raw logs into 'trip segments'.  A trip segment might\n * be an individual trip, a contiguous non-trip region, or the route\n * between two LMFS stops.\n */\nimport _ from \"lodash\";\nimport Trip from \"./Trip\";\nimport HighVelocityJump from \"./HighVelocityJump\";\nimport MissingUpdate from \"./MissingUpdate\";\n\nconst maxDistanceForDwell = 20; // meters\nconst requiredUpdatesForDwell = 12; // aka 2 minute assuming update vehicle request at 10 seconds\n\nclass TripLogs {\n  constructor(rawLogs, solutionType) {\n    this.solutionType = solutionType;\n    if (this.solutionType === \"LMFS\") {\n      this.updateVehicleSuffix = \"update_delivery_vehicle\";\n      this.lastLocationPath =\n        \"jsonPayload.request.deliveryVehicle.lastLocation\";\n    } else {\n      this.updateVehicleSuffix = \"update_vehicle\";\n      this.vehicleName = \"vehicle\";\n      this.lastLocationPath = \"jsonPayload.request.vehicle.lastLocation\";\n    }\n    this.trip_ids = [];\n    this.trips = [];\n    this.tripStatusChanges = [];\n    this.rawLogs = _.reverse(rawLogs);\n    this.processTripSegments();\n    this.minDate = new Date(rawLogs[0].timestamp);\n    this.maxDate = new Date(_.last(rawLogs).timestamp);\n    this.velocityJumps = [];\n    this.missingUpdates = [];\n    this.dwellLocations = [];\n\n    //  annotate with Dates & timestapms\n    _.map(this.rawLogs, (le, idx) => {\n      le.date = new Date(le.timestamp);\n      le.formattedDate = le.date.toISOString();\n      le.timestampMS = le.date.getTime();\n      le.idx = idx;\n    });\n  }\n\n  getRawLogs_(minDate, maxDate) {\n    minDate = minDate || this.minDate;\n    maxDate = maxDate || this.maxDate;\n    return _(this.rawLogs).filter(\n      (le) => le.date >= minDate && le.date <= maxDate\n    );\n  }\n\n  getLogs_(minDate, maxDate) {\n    return this.getRawLogs_(minDate, maxDate)\n      .concat(this.velocityJumps.map((j) => j.getLogViewerEntry()))\n      .concat(this.missingUpdates.map((u) => u.getLogViewerEntry()))\n      .filter((le) => le.date >= minDate && le.date <= maxDate)\n      .sortBy(\"timestampMS\");\n  }\n\n  getTripStatusChanges() {\n    return this.tripStatusChanges;\n  }\n\n  getTripStatusAtDate(date) {\n    const idx = _.sortedIndexBy(this.tripStatusChanges, { date }, \"date\");\n    if (idx >= 1) {\n      return this.tripStatusChanges[idx - 1].newStatus;\n    }\n  }\n\n  getTripIDs() {\n    // TODO: do time filtering heree\n    return this.trip_ids;\n  }\n\n  getTrips() {\n    // TODO: do time filtering heree\n    return this.trips;\n  }\n\n  /*\n   * Vehicles should be updating positions every 5 seconds\n   * (configurable?).  Compute places where updates are missing.\n   * aka \"Temporal jumps\".  This will be places where the\n   * app crashed, the user went off line, lost cell signal, etc.\n   */\n  getMissingUpdates(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new MissingUpdate(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.missingUpdates = MissingUpdate.getSignificantMissingUpdates(entries);\n    return this.missingUpdates;\n  }\n\n  /*\n   * Computes & returns jumps where the vehicle moved\n   * at an unrealistic velocity.\n   */\n  getHighVelocityJumps(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new HighVelocityJump(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.velocityJumps = HighVelocityJump.getSignificantJumps(entries);\n    return this.velocityJumps;\n  }\n\n  /*\n   * Rudimentary dwell location compution.  A lot of issues:\n   *    - Uses size of circle to represent dwell times ... which is confusing\n   *      w.r.t which points make up this cluster. (ie overlapping circles when\n   *      dwell locations are close by).  Should those dwell locations merged?\n   *    - Doesn't compute an actual dwell time, instead assumes UpdateVehicle requests\n   *      are 10 seconds apart\n   *    - A cluster should be within maxDistanceForDwell as well as maxTime in order to be considered\n   *      (right now clusters can be created at a location where multiple trips over days cross)\n   *    - dwell times are fuzzy. Sliders for the time & distance components might be interesting\n   *    - Doesn't respect min/max time filters from the time slider\n   *    - computation of dwell times is slow -- should cache results when turning on & off to avoid\n   *      unnecessary precomputation\n   *    - dwellLocations could be sarted by time to improve cluster lookup\n   *\n   *  See https://stackoverflow.com/questions/36928654/leader-clustering-algorithm-explanation for a\n   *  description of the very simplistic algo used here.\n   */\n  getDwellLocations(minDate, maxDate) {\n    const dwellLocations = [];\n    _.forEach(this.rawLogs, (le) => {\n      const lastLocation = _.get(le, this.lastLocationPath);\n      if (\n        !lastLocation ||\n        !lastLocation.rawLocation ||\n        le.date < minDate ||\n        le.date > maxDate\n      ) {\n        return;\n      }\n      const coord = {\n        lat: lastLocation.rawLocation.latitude,\n        lng: lastLocation.rawLocation.longitude,\n      };\n      const cluster = _.find(\n        dwellLocations,\n        (dl) =>\n          window.google.maps.geometry.spherical.computeDistanceBetween(\n            dl.leaderCoords,\n            new google.maps.LatLng(coord)\n          ) <= maxDistanceForDwell\n      );\n      if (cluster) {\n        cluster.updates++;\n      } else {\n        dwellLocations.push({\n          leaderCoords: new window.google.maps.LatLng(coord),\n          updates: 1,\n        });\n      }\n    });\n\n    this.dwellLocations = _.filter(\n      dwellLocations,\n      (dl) => dl.updates >= requiredUpdatesForDwell\n    );\n\n    return this.dwellLocations;\n  }\n\n  getSegmentID(logEntry) {\n    if (this.solutionType === \"LMFS\") {\n      const stopsLeft = _.get(\n        logEntry,\n        \"jsonPayload.response.remainingVehicleJourneySegments\"\n      );\n      return stopsLeft && \"Stops Left \" + stopsLeft.length;\n    } else {\n      return _.get(logEntry, \"labels.trip_id\");\n    }\n  }\n\n  processTripSegments() {\n    let curTripId = \"this is not a segment\";\n    let curTripData = undefined;\n    let tripIdx = 0;\n    let nonTripIdx = 0;\n    let lastTripStatus = \"no status\";\n    // assumes logs are already sorted\n    // also assumes out-of-order updates can't happen.  Unclear\n    // if this is a good assumption, but it might be worth it to call out\n    // places where it happens (since that might actually be a client bug).\n\n    _.forEach(this.rawLogs, (le) => {\n      if (le.logName.match(this.updateVehicleSuffix)) {\n        const newTripId = this.getSegmentID(le);\n        if (newTripId !== curTripId) {\n          curTripId = newTripId;\n          const tripName = newTripId\n            ? newTripId\n            : \"non-trip-segment-\" + nonTripIdx;\n          curTripData = new Trip(tripIdx, tripName, new Date(le.timestamp));\n          this.trips.push(curTripData);\n          this.trip_ids.push(curTripData.tripName);\n\n          tripIdx++;\n          if (newTripId === undefined) {\n            nonTripIdx++;\n          }\n        } else {\n          curTripData.lastUpdate = new Date(le.timestamp);\n          curTripData.tripDuration =\n            curTripData.lastUpdate - curTripData.firstUpdate;\n          curTripData.updateRequests++;\n        }\n        const lastLocation = _.get(le, this.lastLocationPath);\n        if (lastLocation && lastLocation.rawLocation) {\n          curTripData.appendCoords(lastLocation, le.timestamp);\n        }\n      }\n      const tripStatus = _.get(le, \"jsonPayload.response.status\");\n      // if the logs had a trip status, and it changeed update\n      if (tripStatus && tripStatus !== lastTripStatus) {\n        this.tripStatusChanges.push({\n          newStatus: tripStatus,\n          date: new Date(le.timestamp),\n        });\n        lastTripStatus = tripStatus;\n      }\n    });\n  }\n}\n\nexport { TripLogs as default };\n","/*\n * index.js\n */\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport Map from \"./Map\";\nimport {\n  tripLogs,\n  loadData,\n  apikey,\n  jwt,\n  projectId,\n  solutionType,\n} from \"./vehicleData\";\n\nloadData().then(() => {\n  const logData = {\n    tripLogs,\n    apikey,\n    jwt,\n    projectId,\n    solutionType,\n  };\n  ReactDOM.render(\n    <div>\n      <Map logData={logData} />\n      <App logData={logData} />\n    </div>,\n    document.getElementById(\"root\")\n  );\n});\n"],"sourceRoot":""}