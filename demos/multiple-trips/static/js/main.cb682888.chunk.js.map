{"version":3,"sources":["Map.js","queryString.js","Utils.js","Dataframe.js","TimeSlider.js","LogTable.js","ToggleBar.js","App.js","vehicleData.js","Trip.js","Stats.js","HighVelocityJump.js","MissingUpdate.js","TripLogs.js","index.js"],"names":["mapLoadedResolver","minDate","maxDate","map","apikey","trafficLayer","panorama","jwt","projectId","locationProvider","solutionType","tripLogs","setFeaturedObject","setTimeRange","setQueryStringWithoutPageReload","qsValue","newurl","window","location","protocol","host","pathname","history","pushState","path","getQueryStringValue","key","queryString","search","values","qs","parse","setQueryStringValue","value","newQsValue","stringify","Utils","duration","sec_num","hours","Math","floor","minutes","seconds","timeStr","mapLoadPromise","Promise","resolve","allPaths","allMarkers","dataMakers","bubbleMap","toggleHandlers","render","status","Status","LOADING","FAILURE","addTripPolys","_","forEach","p","setMap","m","lastVehicleCoords","trips","getTrips","vehicleBounds","google","maps","LatLngBounds","trip","bounds","tripCoords","getPathCoords","length","last","Polyline","geodesic","strokeColor","getColor","tripIdx","strokeOpacity","strokeWeight","event","addListener","setOptions","fd","getFeaturedData","firstUpdate","getTime","lastUpdate","getPath","e","extend","push","lastVehicleLocMark","Marker","position","icon","url","scaledSize","Size","title","MyMapComponent","ref","useRef","useEffect","element","urlZoom","urlCenter","current","journeySharing","FleetEngineTripLocationProvider","authTokenFetcher","options","console","log","token","JourneySharingMapView","setZoom","parseInt","setCenter","JSON","fitBounds","getZoom","debounce","getCenter","toJSON","id","style","height","colors","Map","props","logData","urlParams","URLSearchParams","get","apiKey","version","libraries","onSliderChangeMap","rangeStart","rangeEnd","Date","handler","name","GenerateBubbles","bubbleName","cb","showBubble","bubble","getLogs_","le","rawLocation","lastLocation","undefined","LatLng","lat","latitude","lng","longitude","compact","rawLocationLatLng","color","locSensor","accuracy","rawLocationAccuracy","circ","Circle","fillColor","fillOpacity","center","radius","logEntry","clientTimeStr","lastLocationResponse","serverTimeStr","clientDate","serverDate","timeDeltaSeconds","abs","heading","headingLine","icons","SymbolPath","FORWARD_CLOSED_ARROW","offset","geometry","spherical","computeOffset","StreetViewPanorama","document","getElementById","pov","pitch","addressControlOptions","ControlPosition","BOTTOM_CENTER","linksControl","panControl","enableCloseButton","speed","tripStatus","getTripStatusAtDate","date","statusCirc","enabled","TrafficLayer","dwellLocations","getDwellLocations","dl","leaderCoords","updates","startDate","formatDuration","endDate","navStatus","vehicleState","etaDeltas","getETADeltas","etaDelta","coords","min","deltaInSeconds","etaDeltaInSeconds","jumps","getHighVelocityJumps","jump","getStrokeWeight","velocity","startLoc","endLoc","jumpIdx","flatten","missingUpdates","getMissingUpdates","update","interval","offsetHeading","computeHeading","points","scale","CIRCLE","tripId","getTripIDs","Dataframe","src","featuredObject","onSelect","onClick","Range","createSliderWithTooltip","Slider","width","TimeSlider","marks","getTripStatusChanges","change","minVal","maxVal","curMin","max","curMax","step","onChange","onSliderChange","minTime","maxTime","defaultValue","tipFormatter","d","Styles","styled","div","Table","columns","data","onSelectionChange","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","row","getRowProps","original","cells","cell","getCellProps","TrimCell","trim","replace","LogTable","timeRange","React","useMemo","stdColumns","filter","Header","accessor","solutionTypes","Cell","sumBy","indexOf","extraColumns","dotPath","elems","split","Button","button","ButtonToggle","active","ButtonGroup","ToggleBar","toggleState","toggles","toggle","clickHandler","href","docLink","target","rel","getToggleDefault","urlKey","defaultVal","App","nowDate","urlMinTime","urlMaxTime","initialMinTime","initialMaxTime","setFullYear","getFullYear","state","msg","toggleOptions","showGPSBubbles","showHeading","showSpeed","showTraffic","showTripStatus","showDwellLocations","showNavStatus","showETADeltas","showHighVelocityJumps","showMissingUpdates","showLiveJS","showClientServerTimeDeltas","onSliderChangeDebounced","fo","then","updateToggleState","newValue","toggleName","jsonPaths","this","setState","prevState","updateMapToggles","clone","pull","uniq","selectedRow","svgMarker","rotation","anchor","Point","locationForLog","addMarkersToMapForData","select","jsonPath","join","namespace","find","x","without","toggleClickHandler","marginTop","overflowX","overFlowY","float","marginLeft","overFlowX","onDataframePropClick","Component","Trip","tripName","updateRequests","pathCoords","tripDuration","creationTime","computeLength","traveledDistanceKilometers","getTraveledDistance","traveledDistanceMiles","timestamp","trip_id","Stats","dataSet","sorted","sort","ceil","computedOutlier","HighVelocityJump","prevEntry","curEntry","prevLoc","curLoc","distanceTraveled","computeDistanceBetween","timeSpentMS","entry","velocityMPH","toString","computedOutlierVelocity","featureData","timestampMS","formattedDate","toISOString","jsonPayload","velocities","avgVelocity","mean","medianVelocity","median","minVelocity","maxVelocity","sortBy","MissingUpdate","idx","startVehicleState","endVehicleState","temporal_gap","response","getStateTransition","intervals","avgInternal","medianInternal","minInternal","maxInternal","TripLogs","rawLogs","updateVehicleSuffix","vehiclePath","navStatusPropName","vehicleName","lastLocationPath","trip_ids","tripStatusChanges","reverse","processTripSegments","velocityJumps","getRawLogs_","concat","j","getLogViewerEntry","u","sortedIndexBy","newStatus","entries","ret","getSignificantMissingUpdates","getSignificantJumps","coord","cluster","stopsLeft","curTripId","curTripData","nonTripIdx","lastTripStatus","logName","match","newTripId","getSegmentID","appendCoords","a","fetch","json","parsedData","APIKEY","loadData","ReactDOM"],"mappings":"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","file":"static/js/main.cb682888.chunk.js","sourcesContent":["/*\n * Map.js\n *\n * Uses the react-wrapper to make using google maps js sdk\n * easier in react.  Beyond basic loading doesn't pretend to\n * act like a normal react component.\n */\nimport { Wrapper, Status } from \"@googlemaps/react-wrapper\";\nimport { useEffect, useRef } from \"react\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\nimport Utils from \"./Utils\";\n\n/*\n * Expose a promise that resolves when the map is fully instantiated\n */\nlet mapLoadedResolver;\nconst mapLoadPromise = new Promise((resolve) => {\n  mapLoadedResolver = resolve;\n});\n\nlet minDate;\nlet maxDate;\nlet allPaths = [];\nlet allMarkers = [];\nlet map;\nlet apikey;\nlet dataMakers = [];\nlet trafficLayer;\nconst bubbleMap = {};\nconst toggleHandlers = {};\nlet panorama;\nlet jwt;\nlet projectId;\nlet locationProvider;\nlet solutionType;\nlet tripLogs;\nlet setFeaturedObject;\nlet setTimeRange;\n\nconst render = (status) => {\n  if (status === Status.LOADING) return <h3>{status} ..</h3>;\n  if (status === Status.FAILURE) return <h3>{status} ...</h3>;\n  return null;\n};\n\nfunction addTripPolys(map) {\n  _.forEach(allPaths, (p) => p.setMap(null));\n  allPaths = [];\n  _.forEach(allMarkers, (m) => m.setMap(null));\n  allMarkers = [];\n\n  const trips = tripLogs.getTrips();\n  const vehicleBounds = new window.google.maps.LatLngBounds();\n  let lastVehicleCoords;\n  _.forEach(trips, (trip) => {\n    const tripCoords = trip.getPathCoords(minDate, maxDate);\n    if (tripCoords.length > 0) {\n      lastVehicleCoords = _.last(tripCoords);\n      const path = new window.google.maps.Polyline({\n        path: tripCoords,\n        geodesic: true,\n        strokeColor: getColor(trip.tripIdx),\n        strokeOpacity: 0.5,\n        strokeWeight: 6,\n      });\n      google.maps.event.addListener(path, \"mouseover\", () => {\n        path.setOptions({\n          strokeOpacity: 1,\n          strokeWeight: 8,\n        });\n      });\n      google.maps.event.addListener(path, \"mouseout\", () => {\n        path.setOptions({\n          strokeOpacity: 0.5,\n          strokeWeight: 6,\n        });\n      });\n      google.maps.event.addListener(path, \"click\", () => {\n        const fd = trip.getFeaturedData();\n        setFeaturedObject(fd);\n        // TODO: https://github.com/googlemaps/fleet-debugger/issues/79\n        // this time range won't capture the createTrip logs\n        setTimeRange(fd.firstUpdate.getTime(), fd.lastUpdate.getTime());\n      });\n      getPolyBounds(vehicleBounds, path);\n      path.setMap(map);\n      allPaths.push(path);\n    }\n  });\n  if (lastVehicleCoords) {\n    const urlBase = \"http://maps.google.com/mapfiles/kml/shapes/\";\n    const lastVehicleLocMark = new window.google.maps.Marker({\n      position: lastVehicleCoords,\n      map: map,\n      icon: {\n        url: urlBase + (solutionType === \"LMFS\" ? \"truck.png\" : \"cabs.png\"),\n        scaledSize: new google.maps.Size(25, 25),\n      },\n      title: \"Last Location\",\n    });\n    allMarkers.push(lastVehicleLocMark);\n  }\n  return vehicleBounds;\n}\n\n/*\n * Creates the map object using a journeySharing location\n * provider.\n */\nfunction initializeMapObject(element) {\n  // In a more normal implementation authTokenFetcher\n  // would actually be making a RPC to a backend to generate\n  // the jwt.  For debugging use cases the jwt gets bundled into\n  // the extracted log data.\n  function authTokenFetcher(options) {\n    // TODO #25 - bake in actual expiration time -- and give a\n    // better error message for expired jwts\n    console.log(\"Ignoring options using prebuilt jwt\", options);\n    const authToken = {\n      token: jwt,\n    };\n    return authToken;\n  }\n\n  locationProvider =\n    new google.maps.journeySharing.FleetEngineTripLocationProvider({\n      projectId,\n      authTokenFetcher,\n    });\n  const jsMapView = new google.maps.journeySharing.JourneySharingMapView({\n    element: element,\n    locationProvider,\n  });\n  return jsMapView.map;\n}\n\nfunction MyMapComponent() {\n  const ref = useRef();\n\n  useEffect(() => {\n    const urlZoom = getQueryStringValue(\"zoom\");\n    const urlCenter = getQueryStringValue(\"center\");\n    map = initializeMapObject(ref.current);\n    mapLoadedResolver();\n    const vehicleBounds = addTripPolys(map);\n    if (urlZoom && urlCenter) {\n      console.log(\"setting zoom & center from url\", urlZoom, urlCenter);\n      map.setZoom(parseInt(urlZoom));\n      map.setCenter(JSON.parse(urlCenter));\n    } else {\n      map.fitBounds(vehicleBounds);\n    }\n    map.addListener(\"zoom_changed\", () => {\n      setQueryStringValue(\"zoom\", map.getZoom());\n    });\n\n    map.addListener(\n      \"center_changed\",\n      _.debounce(() => {\n        setQueryStringValue(\"center\", JSON.stringify(map.getCenter().toJSON()));\n      }, 100)\n    );\n  });\n\n  return <div ref={ref} id=\"map\" style={{ height: \"500px\" }} />;\n}\n\nfunction getPolyBounds(bounds, p) {\n  p.getPath().forEach((e) => {\n    bounds.extend(e);\n  });\n  return bounds;\n}\n\n/*\n * Deterministically assign a color per trip using tripIdx\n * Colors were chosen for visibility\n */\nfunction getColor(tripIdx) {\n  const colors = [\n    \"#2d7dd2\",\n    \"#97cc04\",\n    \"#eeb902\",\n    \"#f45d01\",\n    \"#474647\",\n    \"00aa00\",\n  ];\n  return colors[tripIdx % colors.length];\n}\n\nfunction Map(props) {\n  tripLogs = props.logData.tripLogs;\n  minDate = tripLogs.minDate.getTime();\n  maxDate = tripLogs.maxDate.getTime();\n  const urlParams = new URLSearchParams(window.location.search);\n  apikey = urlParams.get(\"apikey\") || props.logData.apikey;\n  jwt = props.logData.jwt;\n  projectId = props.logData.projectId;\n  solutionType = props.logData.solutionType;\n\n  return (\n    <Wrapper\n      apiKey={apikey}\n      render={render}\n      version=\"beta\"\n      libraries={[\"geometry\", \"journeySharing\"]}\n    >\n      <MyMapComponent />\n    </Wrapper>\n  );\n}\n\n/*\n * Handler for timewindow change.  Updates global min/max date globals\n * and recomputes the paths as well as all the bubble markers to respect the\n * new date values.\n *\n * Debounced to every 100ms as a blance between performance and reactivity when\n * the slider is dragged.\n */\nconst onSliderChangeMap = _.debounce((rangeStart, rangeEnd) => {\n  minDate = new Date(rangeStart);\n  maxDate = new Date(rangeEnd);\n  addTripPolys(map);\n  _.forEach(toggleHandlers, (handler, name) => {\n    if (bubbleMap[name]) {\n      handler(true);\n    }\n  });\n}, 100);\n\nfunction addMarkersToMapForData(data) {\n  _.forEach(dataMakers, (m) => m.setMap(null));\n  dataMakers = [];\n  const svgMarker = {\n    path: \"M10.453 14.016l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM12 2.016q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z\",\n    fillColor: \"blue\",\n    fillOpacity: 0.6,\n    strokeWeight: 0,\n    rotation: 0,\n    scale: 2,\n    anchor: new google.maps.Point(15, 30),\n  };\n\n  const rawLocation = _.get(data.lastLocation, \"rawLocation\");\n  if (rawLocation) {\n    const status = _.get(data, \"jsonPayload.response.status\");\n    const state = _.get(data, \"jsonPayload.response.state\");\n    const locationForLog = new window.google.maps.Marker({\n      position: { lat: rawLocation.latitude, lng: rawLocation.longitude },\n      map: map,\n      icon: svgMarker,\n      title: \"Vehicle state \" + state + \" Trip Status \" + status,\n    });\n    dataMakers.push(locationForLog);\n  }\n  // TODO: for non-vehicle api calls could attempt to interpolate the location\n}\n\n/*\n * GenerateBubbles() -- helper function for generating map features based\n * on per-log entry data.\n *\n * Handles the gunk of iterating over log entries and clearing/setting the map\n */\nfunction GenerateBubbles(bubbleName, cb) {\n  return (showBubble) => {\n    _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n    delete bubbleMap[bubbleName];\n    if (showBubble) {\n      bubbleMap[bubbleName] = tripLogs\n        .getLogs_(minDate, maxDate)\n        .map((le) => {\n          const lastLocation = le.lastLocation;\n          let rawLocation;\n          let bubble = undefined;\n          if (lastLocation && (rawLocation = lastLocation.rawLocation)) {\n            bubble = cb(\n              new google.maps.LatLng({\n                lat: rawLocation.latitude,\n                lng: rawLocation.longitude,\n              }),\n              lastLocation,\n              le\n            );\n          }\n          return bubble;\n        })\n        .compact()\n        .value();\n    }\n  };\n}\n\n/*\n * Draws circles on map with a radius equal to the\n * GPS accuracy.\n */\ntoggleHandlers[\"showGPSBubbles\"] = GenerateBubbles(\n  \"showGPSBubbles\",\n  (rawLocationLatLng, lastLocation) => {\n    let color;\n    switch (lastLocation.locSensor) {\n      case \"LOCATION_SENSOR_GPS\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_NETWORK\":\n        color = \"#FF1111\";\n        break;\n      case \"LOCATION_SENSOR_PASSIVE\":\n        color = \"#FF0000\";\n        break;\n      case \"LOCATION_SENSOR_ROAD_SNAPPED_LOCATION_PROVIDER\":\n        color = \"#00FF00\";\n        break;\n      case \"LOCATION_SENSOR_FUSED_LOCATION_PROVIDER\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_LOG_UNSPECIFIED\":\n      default:\n        color = \"#000000\";\n    }\n    const accuracy = lastLocation.rawLocationAccuracy;\n    if (accuracy) {\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: accuracy, // units is this actually meters?\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          rawLocationAccuracy: lastLocation.rawLocationAccuracy,\n          locSensor: lastLocation.locSensor,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws circles on map with a radius equal to the\n * time delta (1 meter radius = 1 second of delta)\n */\ntoggleHandlers[\"showClientServerTimeDeltas\"] = GenerateBubbles(\n  \"showClientServerTimeDeltas\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    const clientTimeStr = _.get(\n      logEntry.lastLocationResponse,\n      \"rawLocationTime\"\n    );\n    const serverTimeStr = _.get(logEntry.lastLocationResponse, \"serverTime\");\n    if (clientTimeStr && serverTimeStr) {\n      const clientDate = new Date(clientTimeStr);\n      const serverDate = new Date(serverTimeStr);\n      const timeDeltaSeconds =\n        Math.abs(clientDate.getTime() - serverDate.getTime()) / 1000;\n      let color;\n      if (clientDate > serverDate) {\n        color = \"#0000F0\";\n      } else {\n        color = \"#0F0000\";\n      }\n\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: timeDeltaSeconds,\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          timeDeltaSeconds: timeDeltaSeconds,\n          serverDate: serverDate,\n          clientDate: clientDate,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws arrows on map showing the measured heading\n * of the vehicle (ie which direction vehicle was traveling\n */\ntoggleHandlers[\"showHeading\"] = GenerateBubbles(\n  \"showHeading\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    // Note: Heading & accuracy are only on the _request_ not the\n    // response.\n    const heading = _.get(logEntry.lastLocation, \"heading\");\n    const accuracy = _.get(logEntry.lastLocation, \"bearingAccuracy\");\n\n    // Not currently using accuracy. How to show it?  Maybe opacity of the arrorw?\n    const arrowLength = 20; // meters??\n    if (!(heading && accuracy)) {\n      return;\n    }\n    const headingLine = new google.maps.Polyline({\n      strokeColor: \"#0000F0\",\n      strokeOpacity: 0.6,\n      strokeWeight: 2,\n      icons: [\n        {\n          icon: {\n            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n            strokeColor: \"#0000FF\",\n            strokeWeight: 4,\n          },\n          offset: \"100%\",\n        },\n      ],\n      map,\n      path: [\n        rawLocationLatLng,\n        google.maps.geometry.spherical.computeOffset(\n          rawLocationLatLng,\n          arrowLength,\n          heading\n        ),\n      ],\n    });\n    google.maps.event.addListener(headingLine, \"click\", () => {\n      // TODO: allow updating panorama based on forward/back\n      // stepper buttons (ie at each updatevehicle log we have a heading)\n      panorama = new google.maps.StreetViewPanorama(\n        document.getElementById(\"map\"),\n        {\n          position: rawLocationLatLng,\n          pov: { heading: heading, pitch: 10 },\n          addressControlOptions: {\n            position: google.maps.ControlPosition.BOTTOM_CENTER,\n          },\n          linksControl: false,\n          panControl: false,\n          enableCloseButton: true,\n        }\n      );\n      console.log(\"loaded panorama\", panorama);\n    });\n    return headingLine;\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates vehicle speed at that\n * location.\n */\ntoggleHandlers[\"showSpeed\"] = GenerateBubbles(\n  \"showSpeed\",\n  (rawLocationLatLng, lastLocation) => {\n    const speed = lastLocation.speed;\n    if (lastLocation.speed === undefined) {\n      return;\n    }\n    const color = speed < 0 ? \"#FF0000\" : \"#00FF00\";\n    return new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: Math.abs(speed),\n    });\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates trip status\n * at that location.   Note that trip status isn't actually\n * in the update vehicle logs, so current trip status will actually\n * just be the trip status at the time of the vehicle update  --\n * which is a bit wrong and wonky on the boundaries.\n */\ntoggleHandlers[\"showTripStatus\"] = GenerateBubbles(\n  \"showTripStatus\",\n  (rawLocationLatLng, lastLocation, le) => {\n    let color,\n      radius = 5;\n    const tripStatus = tripLogs.getTripStatusAtDate(le.date);\n    switch (tripStatus) {\n      case \"TRIP_STATUS_NEW\":\n        color = \"#002200\";\n        radius = 30;\n        break;\n      case \"TRIP_STATUS_ENROUTE_TO_PICKUP\":\n        color = \"#FFFF00\";\n        break;\n      case \"TRIP_STATUS_ARRIVED_AT_PICKUP\":\n        color = \"#FFFF10\";\n        radius = 10;\n        break;\n      case \"TRIP_STATUS_ARRIVED_AT_INTERMEDIATE_DESTINATION\":\n        color = \"10FFFF\";\n        radius = 20;\n        break;\n      case \"TRIP_STATUS_ENROUTE_TO_DROPOFF\":\n        color = \"00FFFF\";\n        break;\n      case \"TRIP_STATUS_COMPLETE\":\n        radius = 30;\n        color = \"#00FF00\";\n        break;\n      case \"TRIP_STATUS_CANCELED\":\n        radius = 30;\n        color = \"#FF0000\";\n        break;\n      case \"TRIP_STATUS_UNKNOWN_TRIP_STATUS\":\n      default:\n        color = \"#000000\";\n    }\n\n    const statusCirc = new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: radius, // set based on trip status?\n    });\n    google.maps.event.addListener(statusCirc, \"mouseover\", () => {\n      setFeaturedObject({\n        tripStatus: tripStatus,\n      });\n    });\n    return statusCirc;\n  }\n);\n\n/*\n * Enable/disables live traffic layer\n */\ntoggleHandlers[\"showTraffic\"] = function (enabled) {\n  if (!trafficLayer) {\n    trafficLayer = new google.maps.TrafficLayer();\n  }\n  if (enabled) {\n    trafficLayer.setMap(map);\n  } else {\n    trafficLayer.setMap(null);\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showDwellLocations\"] = function (enabled) {\n  const bubbleName = \"showDwellLocations\";\n  const dwellLocations = tripLogs.getDwellLocations(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(dwellLocations, (dl) => {\n      const circ = new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"#FFFF00\",\n        fillOpacity: 0.25,\n        map,\n        center: dl.leaderCoords,\n        radius: dl.updates * 3, // make dwell times more obvious\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          startDate: dl.startDate,\n          duration: Utils.formatDuration(dl.endDate - dl.startDate),\n          endDate: dl.endDate,\n        });\n      });\n      return circ;\n    });\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showNavStatus\"] = GenerateBubbles(\n  \"showNavStatus\",\n  (rawLocationLatLng, lastLocation, le) => {\n    const navStatus = le.navStatus;\n    if (navStatus === undefined) {\n      return;\n    }\n    let color,\n      radius = 5;\n    switch (navStatus) {\n      case \"NAVIGATION_STATUS_UNKNOWN_NAVIGATION_STATUS\":\n        color = \"#222222\";\n        break;\n      case \"NAVIGATION_STATUS_NO_GUIDANCE\":\n        color = \"#090909\";\n        break;\n      case \"NAVIGATION_STATUS_ENROUTE_TO_DESTINATION\":\n        color = \"#00FF00\";\n        break;\n      case \"NAVIGATION_STATUS_OFF_ROUTE\":\n        color = \"#FF0000\";\n        radius = 30;\n        break;\n      case \"NAVIGATION_STATUS_ARRIVED_AT_DESTINATION\":\n        color = \"0000FF\";\n        radius = 10;\n        break;\n      default:\n        color = \"#000000\";\n    }\n    const statusCirc = new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: radius, // set based on trip status?\n    });\n    google.maps.event.addListener(statusCirc, \"mouseover\", () => {\n      setFeaturedObject({\n        navStatus: navStatus,\n        vehicleState: _.get(le, \"jsonPayload.response.state\"),\n        tripStatus: \"??\",\n      });\n    });\n    return statusCirc;\n  }\n);\n\n/*\n * Draws circles on the map. Size indicates delta in seconds at that\n * location.\n */\ntoggleHandlers[\"showETADeltas\"] = function (enabled) {\n  const bubbleName = \"showETADeltas\";\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  const etaDeltas = tripLogs.getETADeltas(minDate, maxDate);\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(etaDeltas, (etaDelta) => {\n      const circ = new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"FF0000\",\n        fillOpacity: 0.25,\n        map,\n        center: etaDelta.coords,\n        // cap radius to 300 meters to avoid coloring the whole\n        // screen when there is a very large delta.  Definitely\n        // needs tuning ... and likely better to consider adjusting\n        // color as well.\n        radius: _.min([etaDelta.deltaInSeconds, 300]),\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          etaDeltaInSeconds: etaDelta.deltaInSeconds,\n        });\n      });\n      return circ;\n    });\n  }\n};\n\n/*\n * Draws arrows on the map showing where a vehicle jumped\n * from one location to another at an unrealistic velocity.\n */\ntoggleHandlers[\"showHighVelocityJumps\"] = function (enabled) {\n  const bubbleName = \"showHighVelocityJumps\";\n  const jumps = tripLogs.getHighVelocityJumps(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(jumps)\n      .map((jump) => {\n        function getStrokeWeight(velocity) {\n          if (velocity <= 100) {\n            return 2;\n          } else if (velocity < 1000) {\n            return 6;\n          } else if (velocity < 2000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const path = new window.google.maps.Polyline({\n          path: [jump.startLoc, jump.endLoc],\n          geodesic: true,\n          strokeColor: getColor(jump.jumpIdx),\n          strokeOpacity: 0.8,\n          strokeWeight: getStrokeWeight(jump.velocity),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: getColor(jump.jumpIdx),\n                strokeWeight: getStrokeWeight(jump.velocity),\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n          // show a minute +/- on each side of a jump\n          setTimeRange(\n            jump.startDate.getTime() - 60 * 1000,\n            jump.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Marks locations on the map where we did not get the expected\n * updateVehicle requests\n */\ntoggleHandlers[\"showMissingUpdates\"] = function (enabled) {\n  const bubbleName = \"showMissingUpdates\";\n  const missingUpdates = tripLogs.getMissingUpdates(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(missingUpdates)\n      .map((update) => {\n        function getStrokeWeight(interval) {\n          if (interval <= 60 * 1000) {\n            return 2;\n          } else if (interval < 60 * 10 * 1000) {\n            return 6;\n          } else if (interval < 60 * 60 * 10 * 1000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const heading = google.maps.geometry.spherical.computeHeading(\n          update.startLoc,\n          update.endLoc\n        );\n        const offsetHeading = ((heading + 360 + 90) % 360) - 180;\n        const points = [\n          update.startLoc,\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          update.endLoc,\n        ];\n        const path = new window.google.maps.Polyline({\n          path: points,\n          geodesic: true,\n          strokeColor: \"#008B8B\",\n          strokeOpacity: 0.5,\n          strokeWeight: getStrokeWeight(update.interval),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: \"#008B8B\",\n                strokeWeight: getStrokeWeight(update.interval),\n                scale: 6,\n              },\n              offset: \"50%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"0%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          path.setOptions({\n            strokeOpacity: 1,\n            strokeWeight: 1.5 * getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"mouseout\", () => {\n          path.setOptions({\n            strokeOpacity: 0.5,\n            strokeWeight: getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          // show a minute +/- on each side of a update\n          setTimeRange(\n            update.startDate.getTime() - 60 * 1000,\n            update.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Enable/disables live journey sharing view\n */\ntoggleHandlers[\"showLiveJS\"] = function (enabled) {\n  if (!jwt) {\n    console.log(\"Issue #25 -- no/invalid jwt\");\n    return;\n  }\n  // call into js to set the trip\n  if (enabled) {\n    locationProvider.tripId = _.last(tripLogs.getTripIDs());\n  } else {\n    locationProvider.tripId = \"\";\n  }\n};\n\nfunction updateMapToggles(toggleName, enabled) {\n  toggleHandlers[toggleName](enabled);\n}\n\n/*\n * Register handlers that allow this code to call\n * into react components.  (ie display trip data\n * in the object viewer component when a vehicle track\n * polyline  is clicked on).\n */\nfunction registerHandlers(featureObject, timeRange) {\n  setFeaturedObject = featureObject;\n  setTimeRange = timeRange;\n}\n\nexport {\n  Map as default,\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n  mapLoadPromise,\n};\n","import qs from \"query-string\";\n\nconst setQueryStringWithoutPageReload = (qsValue) => {\n  const newurl =\n    window.location.protocol +\n    \"//\" +\n    window.location.host +\n    window.location.pathname +\n    qsValue;\n  window.history.pushState({ path: newurl }, \"\", newurl);\n};\n\nexport const getQueryStringValue = (\n  key,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  return values[key];\n};\n\nexport const setQueryStringValue = (\n  key,\n  value,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  const newQsValue = qs.stringify({\n    ...values,\n    [key]: value,\n  });\n  setQueryStringWithoutPageReload(`?${newQsValue}`);\n};\n","class Utils {\n  /*\n   * Formats a duration into something friendly\n   * for human consumption.\n   */\n  static formatDuration(duration) {\n    let sec_num = duration / 1000;\n    let hours = Math.floor(sec_num / 3600);\n    let minutes = Math.floor((sec_num - hours * 3600) / 60);\n    let seconds = Math.floor(sec_num - hours * 3600 - minutes * 60);\n    let timeStr = \"\";\n\n    if (hours > 0) {\n      timeStr += hours + \" hours \";\n    }\n    if (minutes > 0) {\n      timeStr += minutes + \" minutes \";\n    }\n    if (seconds > 0) {\n      timeStr += seconds + \" seconds\";\n    }\n    return timeStr;\n  }\n}\nexport { Utils as default };\n","/*\n * Dataframe.js\n *\n * JSON viewer for log entries.   Clicking on a property _value_\n * adds it to the log viewer.\n *\n * TODO: support clicking on the property name as well, or support an\n * icon or other UI element (similar to copy to clip board).\n */\nimport ReactJson from \"react-json-view\";\nfunction Dataframe(props) {\n  return <ReactJson src={props.featuredObject} onSelect={props.onClick} />;\n}\n\n// TODO: Ideas: allow selecting a field and see how it changes along the map\n// or the slider (ie view on map / view on slider)\n// or 'add slider' that instantiates a slider that has marks\n// when that value changes\nexport default Dataframe;\n","/*\n * TimeSlider.js\n *\n * Provides a time-based visualaziton of key events (vehicle status changes) as well\n * as filtering control for the log viewer & map view.\n *\n * TODO: not clear that rc-slider is actually the correct/best component for this\n * functionality\n */\nimport Slider from \"rc-slider\";\nimport \"rc-slider/assets/index.css\";\nimport _ from \"lodash\";\n\nconst { createSliderWithTooltip } = Slider;\nconst Range = createSliderWithTooltip(Slider.Range);\n\nconst style = { width: \"100%\" };\n\nfunction TimeSlider(props) {\n  const tripLogs = props.logData.tripLogs;\n  const marks = {};\n\n  // Add marks showing when trip status changed.\n  // Ideally label by trip status change ... but labels overrun & look ugly\n  _.map(tripLogs.getTripStatusChanges(), (change) => {\n    marks[change.date.getTime()] = {};\n  });\n\n  const minVal = tripLogs.minDate.getTime();\n  const maxVal = tripLogs.maxDate.getTime();\n\n  const curMin = _.max([minVal, props.curMin]);\n  const curMax = _.min([maxVal, props.curMax]);\n\n  function onChange(value) {\n    props.onSliderChange({\n      minTime: value[0],\n      maxTime: value[1],\n    });\n  }\n\n  function formatTooltip(value) {\n    const d = new Date(value);\n    const tripStatus = tripLogs.getTripStatusAtDate(new Date(value));\n    return `${d}${tripStatus}`;\n  }\n\n  return (\n    <div style={style}>\n      <Range\n        min={minVal}\n        max={maxVal}\n        marks={marks}\n        step={1}\n        onChange={onChange}\n        defaultValue={[minVal, maxVal]}\n        value={[curMin, curMax]}\n        tipFormatter={formatTooltip}\n      />\n    </div>\n  );\n}\n\nexport default TimeSlider;\n","/*\n * LogTable.js\n *\n * Handles the log viewing component.\n */\nimport { useTable } from \"react-table\";\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\n\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n  }\n`;\n\nfunction Table({ columns, data, onSelectionChange }) {\n  const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } =\n    useTable({\n      columns,\n      data,\n    });\n\n  return (\n    <table {...getTableProps()}>\n      <thead>\n        {headerGroups.map((headerGroup) => (\n          <tr {...headerGroup.getHeaderGroupProps()}>\n            {headerGroup.headers.map((column) => (\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\n            ))}\n          </tr>\n        ))}\n      </thead>\n      <tbody {...getTableBodyProps()}>\n        {rows.map((row) => {\n          prepareRow(row);\n          return (\n            <tr\n              {...row.getRowProps()}\n              onClick={() => onSelectionChange(row.original)}\n            >\n              {row.cells.map((cell) => {\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\n              })}\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\n/*\n * Helper method for removing common substrings in cells.  Typically\n * used for removing a prefix from ENUMs.\n */\nconst TrimCell = ({ value, trim }) => {\n  return <>{value && value.replace(trim, \"\")}</>;\n};\n\nfunction LogTable(props) {\n  const minTime = props.timeRange.minTime;\n  const maxTime = props.timeRange.maxTime;\n  const data = props.logData.tripLogs\n    .getLogs_(new Date(minTime), new Date(maxTime))\n    .value();\n\n  const columns = React.useMemo(() => {\n    const stdColumns = _.filter(\n      [\n        {\n          Header: \"Date\",\n          accessor: \"formattedDate\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"SDK Version\",\n          accessor: \"jsonPayload.request.header.sdkVersion\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"OS Version\",\n          accessor: \"jsonPayload.request.header.osVersion\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"Method\",\n          accessor: \"jsonPayload.@type\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell\n              value={value}\n              trim=\"type.googleapis.com/maps.fleetengine.\"\n            />\n          ),\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"Vehicle\",\n          accessor: \"labels.vehicle_id\",\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Vehicle\",\n          accessor: \"labels.delivery_vehicle_id\",\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Trip\",\n          accessor: \"labels.trip_id\",\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Vehicle State\",\n          accessor: \"jsonPayload.response.state\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"VEHICLE_STATE_\" />\n          ),\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Task State\",\n          accessor: \"jsonPayload.response.state\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"TASK_STATE_\" />\n          ),\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Trip Status\",\n          accessor: \"jsonPayload.response.status\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"TRIP_STATUS_\" />\n          ),\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Remaining tasks\",\n          id: \"reamining_tasks\",\n          accessor: \"jsonPayload.response.remainingVehicleJourneySegments\",\n          Cell: ({ cell: { value } }) => (\n            <>{value && _.sumBy(value, \"stop.tasks.length\")}</>\n          ),\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Remaining Distance This Segment\",\n          accessor:\n            \"jsonPayload.request.deliveryVehicle.remainingDistanceMeters\",\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Remaining Segements\",\n          accessor: \"jsonPayload.response.remainingVehicleJourneySegments\",\n          Cell: ({ cell: { value } }) => <>{value && value.length}</>,\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Nav Status\",\n          // XXX request or response best?\n          accessor: \"navStatus\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"NAVIGATION_STATUS_\" />\n          ),\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n      ],\n      (column) => {\n        return column.solutionTypes.indexOf(props.logData.solutionType) !== -1;\n      }\n    );\n\n    // Add dynamic columns\n    _.map(props.extraColumns, (dotPath) => {\n      const elems = dotPath.split(\".\");\n      stdColumns.push({\n        Header: elems[elems.length - 1],\n        accessor: dotPath,\n      });\n    });\n    const headers = [\n      {\n        Header: \"Log Entries (click row to view full log entry)\",\n        columns: stdColumns,\n      },\n    ];\n    return headers;\n  }, [props.extraColumns]);\n\n  return (\n    <Styles>\n      <Table\n        columns={columns}\n        data={data}\n        onSelectionChange={props.onSelectionChange}\n      />\n    </Styles>\n  );\n}\n\nexport { LogTable as default };\n","/*\n * ToggleBar.js\n *\n * Row of buttons that configure visualization options on the map\n */\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\nconst Button = styled.button``;\nconst ButtonToggle = styled(Button)`\n  opacity: 0.6;\n  ${({ active }) =>\n    active &&\n    `\n    opacity: 1;\n    color: Green;\n  `}\n`;\n\nconst ButtonGroup = styled.div`\n  display: flex;\n`;\nfunction ToggleBar(props) {\n  const toggleState = props.toggleState;\n  const toggles = _.map(props.toggles, (toggle) => {\n    return (\n      <ButtonToggle\n        key={toggle.id}\n        active={toggleState[toggle.id]}\n        onClick={() => props.clickHandler(toggle.id)}\n      >\n        {toggle.name}\n        <a href={toggle.docLink} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n    );\n  });\n  return <ButtonGroup>{toggles}</ButtonGroup>;\n}\n\nexport default ToggleBar;\n","/*\n * App.js\n *\n * Basic react app container.  Handles state for the app and\n * propagation for state changes into the non-react map\n */\nimport React from \"react\";\nimport {\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n  mapLoadPromise,\n} from \"./Map\";\nimport Dataframe from \"./Dataframe\";\nimport TimeSlider from \"./TimeSlider\";\nimport LogTable from \"./LogTable\";\nimport ToggleBar from \"./ToggleBar\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\n\n/**\n * returns the default value for the button from the url\n */\nfunction getToggleDefault(urlKey, defaultVal) {\n  const urlVal = getQueryStringValue(urlKey);\n  if (urlVal === \"true\") {\n    defaultVal = true;\n  }\n  return defaultVal;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    const nowDate = new Date();\n    let urlMinTime = getQueryStringValue(\"minTime\");\n    let urlMaxTime = getQueryStringValue(\"maxTime\");\n    this.initialMinTime = urlMinTime ? parseInt(urlMinTime) : 0;\n    // default max time to 1 year in the future\n    this.initialMaxTime = urlMaxTime\n      ? parseInt(urlMaxTime)\n      : nowDate.setFullYear(nowDate.getFullYear() + 1);\n\n    this.logData = props.logData;\n    this.state = {\n      timeRange: {\n        minTime: this.initialMinTime,\n        maxTime: this.initialMaxTime,\n      },\n      featuredObject: { msg: \"Click a table row to select object\" },\n      extraColumns: [],\n      toggleOptions: {\n        showGPSBubbles: getToggleDefault(\"showGPSBubbles\", false),\n        showHeading: getToggleDefault(\"showHeading\", false),\n        showSpeed: getToggleDefault(\"showSpeed\", false),\n        showTraffic: getToggleDefault(\"showTraffic\", false),\n        showTripStatus: getToggleDefault(\"showTripStatus\", false),\n        showDwellLocations: getToggleDefault(\"showDwellLocations\", false),\n        showNavStatus: getToggleDefault(\"showNavStatus\", false),\n        showETADeltas: getToggleDefault(\"showETADeltas\", false),\n        showHighVelocityJumps: getToggleDefault(\"showHighVelocityJumps\", false),\n        showMissingUpdates: getToggleDefault(\"showMissingUpdates\", false),\n        showLiveJS: getToggleDefault(\"showLiveJS\", false),\n        showClientServerTimeDeltas: getToggleDefault(\n          \"showClientServerTimeDeltas\",\n          false\n        ),\n      },\n    };\n    // Realtime updates are too heavy.  There must be a better/ react way\n    this.onSliderChangeDebounced = _.debounce(\n      (timeRange) => this.onSliderChange(timeRange),\n      25\n    );\n\n    // Allow map code to set which object is featured, and\n    // adjust the timerange filtering\n    registerHandlers(\n      (fo) => this.setFeaturedObject(fo),\n      (minTime, maxTime) => this.setTimeRange(minTime, maxTime)\n    );\n    // TODO: refactor so that visualizations are registered\n    // rather than enumerated here?\n    this.toggles = _.filter(\n      [\n        {\n          id: \"showGPSBubbles\",\n          name: \"GPS Accuracy\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/GPSAccuracy.md\",\n          columns: [\n            \"lastLocation.rawLocationAccuracy\",\n            \"lastLocation.locSensor\",\n          ],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showHeading\",\n          name: \"Heading\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Heading.md\",\n          columns: [\"lastLocation.heading\", \"lastLocation.bearingAccuracy\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showSpeed\",\n          name: \"Speed\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Speed.md\",\n          columns: [\"lastLocation.speed\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showTripStatus\",\n          name: \"Trip Status\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/TripStatus.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          id: \"showNavStatus\",\n          name: \"Navigation Status\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/NavStatus.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showDwellLocations\",\n          name: \"Dwell Locations\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/DwellTimes.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showHighVelocityJumps\",\n          name: \"Jumps (unrealistic velocity)\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/VelocityJumps.md\",\n          columns: [\"lastLocation.speed\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showMissingUpdates\",\n          name: \"Jumps (Temporal)\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/MissingUpdates.md\",\n          columns: [\"jsonPayload.temporal_gap\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showClientServerTimeDeltas\",\n          name: \"Client/Server Time Deltas\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [\n            \"jsonPayload.response.lastLocation.rawLocationTime\",\n            \"jsonPayload.response.lastLocation.serverTime\",\n          ],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showETADeltas\",\n          name: \"ETA Deltas\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/EtaDeltas.md\",\n          columns: [\"jsonPayload.request.vehicle.etaToFirstWaypoint\"],\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          id: \"showTraffic\",\n          name: \"Traffic\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showLiveJS\",\n          name: \"Start Live Journey Sharing for newest trip\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n      ],\n      (toggle) => {\n        return toggle.solutionTypes.indexOf(this.logData.solutionType) !== -1;\n      }\n    );\n  }\n\n  /*\n   * Update react state from data in the url.  This could/should be\n   * cleaned up.  The pure react state is actually set properly in the\n   * constructor ... all this does is update the map and associated\n   * data (once it's loaded).  Given this split it's definitely possible\n   * that this just overwrites settings a quickfingered user already\n   * changed.\n   */\n  componentDidMount() {\n    mapLoadPromise.then(() => {\n      this.setTimeRange(this.initialMinTime, this.initialMaxTime);\n      _.map(this.toggles, (toggle) => {\n        const urlVal = getQueryStringValue(toggle.id);\n        if (urlVal === \"true\") {\n          this.updateToggleState(true, toggle.id, toggle.columns);\n        }\n      });\n    });\n  }\n\n  updateToggleState(newValue, toggleName, jsonPaths) {\n    this.setState((prevState) => {\n      prevState.toggleOptions[toggleName] = newValue;\n      updateMapToggles(toggleName, newValue);\n      setQueryStringValue(toggleName, newValue);\n\n      const extraColumns = _.clone(prevState.extraColumns);\n      _.forEach(jsonPaths, (path) => {\n        if (newValue) {\n          extraColumns.push(path);\n        } else {\n          _.pull(extraColumns, path);\n        }\n      });\n      prevState.extraColumns = _.uniq(extraColumns);\n\n      return prevState;\n    });\n  }\n\n  /*\n   * Updates react state associated with the slider and calls into\n   * the non-react map code to do the same.\n   */\n  onSliderChange(timeRange) {\n    this.setTimeRange(timeRange.minTime, timeRange.maxTime);\n  }\n\n  /*\n   * Callback to updated selected log row\n   */\n  onSelectionChange(selectedRow) {\n    addMarkersToMapForData(selectedRow);\n    this.setFeaturedObject(selectedRow);\n  }\n\n  /*\n   * Set the featured object\n   */\n  setFeaturedObject(featuredObject) {\n    this.setState({ featuredObject: featuredObject });\n  }\n\n  /*\n   * exposes editing of the timeRange state\n   */\n  setTimeRange(minTime, maxTime) {\n    setQueryStringValue(\"minTime\", minTime);\n    setQueryStringValue(\"maxTime\", maxTime);\n    this.setState({\n      timeRange: {\n        minTime: minTime,\n        maxTime: maxTime,\n      },\n    });\n\n    // Handle Map component separately from standard state update\n    onSliderChangeMap(minTime, maxTime);\n  }\n\n  /*\n   * Callback to handle clicks on properties in the json viewer.\n   * Adds/removes row from the log viewer based on which property\n   * in the json object was clicked on\n   */\n  onDataframePropClick(select) {\n    this.setState((prevState) => {\n      const jsonPath = _.join(select.namespace, \".\") + \".\" + select.name;\n      let newColumns;\n      if (_.find(prevState.extraColumns, (x) => x === jsonPath)) {\n        newColumns = _.without(prevState.extraColumns, jsonPath);\n      } else {\n        newColumns = [...prevState.extraColumns, jsonPath];\n      }\n      return {\n        extraColumns: newColumns,\n      };\n    });\n  }\n\n  toggleClickHandler(id) {\n    const toggle = _.find(this.toggles, { id });\n    const newValue = !this.state.toggleOptions[id];\n    this.updateToggleState(newValue, id, toggle.columns);\n  }\n\n  render() {\n    return (\n      <div>\n        <TimeSlider\n          logData={this.logData}\n          curMin={this.state.timeRange.minTime}\n          curMax={this.state.timeRange.maxTime}\n          onSliderChange={this.onSliderChangeDebounced}\n        />\n        <ToggleBar\n          toggles={this.toggles}\n          toggleState={this.state.toggleOptions}\n          clickHandler={(id) => this.toggleClickHandler(id)}\n        />\n        <div style={{ width: \"100%\", marginTop: \"20px\" }}>\n          <div\n            style={{\n              width: \"65%\",\n              overflowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n              float: \"left\",\n            }}\n          >\n            <LogTable\n              logData={this.logData}\n              style={{ width: \"100%\" }}\n              timeRange={this.state.timeRange}\n              extraColumns={this.state.extraColumns}\n              onSelectionChange={(featuredObject) =>\n                this.onSelectionChange(featuredObject)\n              }\n            />\n          </div>\n          <div\n            style={{\n              marginLeft: \"65%\",\n              overFlowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n            }}\n          >\n            <Dataframe\n              featuredObject={this.state.featuredObject}\n              onClick={(select) => this.onDataframePropClick(select)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { App as default };\n","/*\n * vehicleData.js\n *\n * Load raw log data for easier consumption by other components.\n */\nimport TripLogs from \"./TripLogs\";\nlet jwt;\nlet projectId;\nlet apikey;\nlet solutionType;\nlet tripLogs;\n\n/**\n * This function must be called (and awaited on) to load the raw data before\n * any of the other exported fields are accessed.\n */\nasync function loadData() {\n  const response = await fetch(\"./data.json\");\n  const parsedData = await response.json();\n  jwt = parsedData.jwt;\n  projectId = parsedData.projectId;\n  apikey = parsedData.APIKEY;\n  solutionType = parsedData.solutionType || \"ODRD\";\n  tripLogs = new TripLogs(parsedData.rawLogs, solutionType);\n}\n\nexport { loadData, tripLogs, apikey, jwt, projectId, solutionType };\n","/*\n * Trip.js\n *\n * Processed log for a trip. Currently only includes very basic information\n * about the trip\n */\nimport _ from \"lodash\";\nimport Utils from \"./Utils\";\n\nclass Trip {\n  constructor(tripIdx, tripName, firstUpdate) {\n    this.tripIdx = tripIdx;\n    this.tripName = tripName;\n    this.updateRequests = 1;\n    this.pathCoords = [];\n    this.tripDuration = 0;\n    this.creationTime = \"Unknown\";\n    this.firstUpdate = firstUpdate;\n    this.lastUpdate = \"Unknown\";\n  }\n\n  getTraveledDistance() {\n    return window.google.maps.geometry.spherical.computeLength(this.pathCoords);\n  }\n\n  /*\n   * Returns data about trip to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      updateRequests: this.updateRequests,\n      tripName: this.tripName,\n      duration: Utils.formatDuration(this.tripDuration),\n      creationTime: this.creationTime,\n      traveledDistanceKilometers: this.getTraveledDistance() / 1000,\n      traveledDistanceMiles: this.getTraveledDistance() / 1609,\n      firstUpdate: this.firstUpdate,\n      lastUpdate: this.lastUpdate,\n    };\n  }\n\n  getPathCoords(minDate, maxDate) {\n    if (!(minDate && maxDate)) {\n      return this.pathCoords;\n    }\n    return _(this.pathCoords)\n      .filter((le) => {\n        return le.date >= minDate && le.date <= maxDate;\n      })\n      .value();\n  }\n\n  // append full raw log? would make downstream processing easier\n  // or synthesize pathCoords on the fly?\n  appendCoords(lastLocation, timestamp) {\n    this.pathCoords.push({\n      lat: lastLocation.rawLocation.latitude,\n      lng: lastLocation.rawLocation.longitude,\n      trip_id: this.tripName,\n      date: new Date(timestamp),\n    });\n  }\n}\nexport { Trip as default };\n","/*\n * stats helpers\n */\nclass Stats {\n  static median(dataSet) {\n    if (dataSet.length === 1) return dataSet[0];\n    const sorted = [...dataSet].sort();\n    const ceil = Math.ceil(sorted.length / 2);\n    const floor = Math.floor(sorted.length / 2);\n    if (ceil === floor) return sorted[floor];\n    return (sorted[ceil] + sorted[floor]) / 2;\n  }\n}\nexport { Stats as default };\n","/*\n * HighVelocityJump.js\n *\n * Representation of a HighVelocityJump\n */\nimport _ from \"lodash\";\nconst velocityOutlier = 68; // true velocities higher than this unlikely (in Meters/sec aprrox 150 MPH)\nimport Stats from \"./Stats\";\nlet computedOutlier = 0;\n\nclass HighVelocityJump {\n  constructor(jumpIdx, prevEntry, curEntry) {\n    const prevLoc = prevEntry.lastLocation;\n    const curLoc = curEntry.lastLocation;\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    const distanceTraveled =\n      window.google.maps.geometry.spherical.computeDistanceBetween(\n        startLoc,\n        endLoc\n      );\n    const timeSpentMS = curEntry.date - prevEntry.date;\n    const velocity = distanceTraveled / (timeSpentMS / 1000.0);\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.timeSpentMS = timeSpentMS;\n    this.distanceTraveled = distanceTraveled;\n    this.velocity = velocity;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.jumpIdx = jumpIdx;\n  }\n\n  /*\n   * Returns data about the jump to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      timeSpentMS: this.timeSpentMS,\n      distanceTraveled: this.distanceTraveled,\n      velocity: this.velocity,\n      velocityMPH: this.velocity * 2.237,\n      startLoc: this.startLoc.toString(),\n      startDate: this.prevEntry.date,\n      endDate: this.entry.date,\n      endLoc: this.endLoc.toString(),\n      jumpIdx: this.jumpIdx,\n      date: this.entry.date,\n      computedOutlierVelocity: computedOutlier,\n    };\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Jump\",\n    };\n    featureData.lastLocation = {\n      speed: this.velocity,\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters jumps down to instances where the vehicle was\n   * travelling at an unrealistic speed (either\n   * greater that 150 MPH, or 100x median velocity).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantJumps(jumps) {\n    if (!jumps) {\n      return [];\n    }\n    const velocities = _.map(jumps, \"velocity\");\n    const avgVelocity = _.mean(velocities);\n    const medianVelocity = Stats.median(velocities);\n    const minVelocity = _.min(velocities);\n    const maxVelocity = _.max(velocities);\n    console.log(\"avgVelocity\", avgVelocity);\n    console.log(\"medianVelocity\", medianVelocity);\n    console.log(\"minVelocity\", minVelocity);\n    console.log(\"maxVelocity\", maxVelocity);\n    computedOutlier = _.min([velocityOutlier, medianVelocity * 100]);\n    return _(jumps)\n      .filter((e) => e.velocity >= computedOutlier)\n      .sortBy(\"velocity\")\n      .value();\n  }\n}\nexport { HighVelocityJump as default };\n","/*\n * MissingUpdate.js\n *\n * Representation of a missing update\n */\nimport _ from \"lodash\";\nconst updateOutlier = 60000; // 60 seconds\nimport Stats from \"./Stats\";\nimport Utils from \"./Utils\";\nlet computedOutlier = 0;\n\nclass MissingUpdate {\n  constructor(idx, prevEntry, curEntry) {\n    const interval = curEntry.date - prevEntry.date;\n    const curLoc = curEntry.lastLocation;\n    const prevLoc = prevEntry.lastLocation;\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.interval = interval;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.idx = idx;\n    this.startVehicleState = _.get(curEntry, \"jsonPayload.response.state\");\n    this.endVehicleState = _.get(prevEntry, \"jsonPayload.response.state\");\n    this.duration = Utils.formatDuration(this.interval);\n  }\n\n  /*\n   * Returns data about the update to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      duration: this.duration,\n      interval: this.interval,\n      startDate: this.startDate,\n      startLoc: this.startLoc.toString(),\n      endDate: this.endDate,\n      endLoc: this.endLoc.toString(),\n      startVehicleState: this.startVehicleState,\n      endVehicleState: this.endVehicleState,\n      computedOutlier: Utils.formatDuration(computedOutlier),\n    };\n  }\n\n  /*\n   * format a vehicle state transitino into something a\n   * human can easily read.\n   */\n  getStateTransition() {\n    const start = this.startVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    const end = this.endVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    return start + \">\" + end;\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.date = this.startDate;\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Missing Updates\",\n      temporal_gap: featureData.duration,\n      response: {\n        state: this.getStateTransition(),\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters updates down to instances where now updates\n   * were received from the vehicle for either 60 seconds\n   * or 10x the median observed update (our default\n   * update is every 5 seconds).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantMissingUpdates(updates) {\n    if (!updates) {\n      return [];\n    }\n    const intervals = _.map(updates, \"interval\");\n    const avgInternal = _.mean(intervals);\n    const medianInternal = Stats.median(intervals);\n    const minInternal = _.min(intervals);\n    const maxInternal = _.max(intervals);\n    console.log(\"avgInternal\", avgInternal);\n    console.log(\"medianInternal\", medianInternal);\n    console.log(\"minInternal\", minInternal);\n    console.log(\"maxInternal\", maxInternal);\n    console.log(\"updateOutlier\", updateOutlier);\n    computedOutlier = _.min([medianInternal * 10, updateOutlier]);\n    console.log(\"computedOutlier\", computedOutlier);\n    return _(updates)\n      .filter((e) => e.interval >= computedOutlier)\n      .sortBy(\"interval\")\n      .value();\n  }\n}\nexport { MissingUpdate as default };\n","/*\n * TripLogs.js\n *\n * Processes raw logs into 'trip segments'.  A trip segment might\n * be an individual trip, a contiguous non-trip region, or the route\n * between two LMFS stops.\n */\nimport _ from \"lodash\";\nimport Trip from \"./Trip\";\nimport HighVelocityJump from \"./HighVelocityJump\";\nimport MissingUpdate from \"./MissingUpdate\";\n\nconst maxDistanceForDwell = 20; // meters\nconst requiredUpdatesForDwell = 12; // aka 2 minute assuming update vehicle request at 10 seconds\n\nclass TripLogs {\n  constructor(rawLogs, solutionType) {\n    this.solutionType = solutionType;\n    if (this.solutionType === \"LMFS\") {\n      this.updateVehicleSuffix = \"update_delivery_vehicle\";\n      this.vehiclePath = \"jsonPayload.request.deliveryVehicle\";\n      this.navStatusPropName = \"navigationStatus\";\n    } else {\n      this.updateVehicleSuffix = \"update_vehicle\";\n      this.vehicleName = \"vehicle\";\n      this.vehiclePath = \"jsonPayload.request.vehicle\";\n      this.navStatusPropName = \"navStatus\";\n    }\n    this.lastLocationPath = this.vehiclePath + \".lastLocation\";\n    this.trip_ids = [];\n    this.trips = [];\n    this.tripStatusChanges = [];\n    this.rawLogs = _.reverse(rawLogs);\n    this.processTripSegments();\n    this.minDate = new Date(rawLogs[0].timestamp);\n    this.maxDate = new Date(_.last(rawLogs).timestamp);\n    this.velocityJumps = [];\n    this.missingUpdates = [];\n    this.dwellLocations = [];\n    this.etaDeltas = [];\n\n    //  annotate with Dates & timestapms\n    _.map(this.rawLogs, (le, idx) => {\n      le.date = new Date(le.timestamp);\n      le.formattedDate = le.date.toISOString();\n      le.timestampMS = le.date.getTime();\n      le.idx = idx;\n      // \"synthetic\" entries that hides some of the differences\n      // between lmfs & odrd log entries\n      le.lastLocation = _.get(le, this.lastLocationPath);\n\n      // utilized for calculations of serve/client time deltas (where the\n      // server time isn't populated in the request).\n      le.lastLocationResponse = _.get(le, \"jsonPayload.response.lastLocation\");\n\n      // use the response because nav status is typically only\n      // in the request when it changes ... and visualizations\n      // make more sense when the nav status can be shown along the route\n      le.navStatus = _.get(\n        le,\n        \"jsonPayload.response.\" + this.navStatusPropName\n      );\n    });\n  }\n\n  getRawLogs_(minDate, maxDate) {\n    minDate = minDate || this.minDate;\n    maxDate = maxDate || this.maxDate;\n    return _(this.rawLogs).filter(\n      (le) => le.date >= minDate && le.date <= maxDate\n    );\n  }\n\n  getLogs_(minDate, maxDate) {\n    return this.getRawLogs_(minDate, maxDate)\n      .concat(this.velocityJumps.map((j) => j.getLogViewerEntry()))\n      .concat(this.missingUpdates.map((u) => u.getLogViewerEntry()))\n      .filter((le) => le.date >= minDate && le.date <= maxDate)\n      .sortBy(\"timestampMS\");\n  }\n\n  getTripStatusChanges() {\n    return this.tripStatusChanges;\n  }\n\n  getTripStatusAtDate(date) {\n    const idx = _.sortedIndexBy(this.tripStatusChanges, { date }, \"date\");\n    if (idx >= 1) {\n      return this.tripStatusChanges[idx - 1].newStatus;\n    }\n  }\n\n  getTripIDs() {\n    // TODO: do time filtering heree\n    return this.trip_ids;\n  }\n\n  getTrips() {\n    // TODO: do time filtering heree\n    return this.trips;\n  }\n\n  /*\n   * Vehicles should be updating positions every 5 seconds\n   * (configurable?).  Compute places where updates are missing.\n   * aka \"Temporal jumps\".  This will be places where the\n   * app crashed, the user went off line, lost cell signal, etc.\n   */\n  getMissingUpdates(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new MissingUpdate(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.missingUpdates = MissingUpdate.getSignificantMissingUpdates(entries);\n    return this.missingUpdates;\n  }\n\n  /*\n   * Compute change in ETA to first waypoint across all location\n   * updates.\n   */\n  getETADeltas(minDate, maxDate) {\n    let prevEntry;\n    this.etaDeltas = this.getRawLogs_(minDate, maxDate)\n      .filter(\n        (le) =>\n          _.get(le, this.vehiclePath + \".etaToFirstWaypoint\") &&\n          _.get(le, this.lastLocationPath + \".rawLocation\")\n      )\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          const curLoc = _.get(curEntry, this.lastLocationPath);\n\n          ret = {\n            deltaInSeconds: (curEntry.date - prevEntry.date) / 1000,\n            coords: new google.maps.LatLng({\n              lat: curLoc.rawLocation.latitude,\n              lng: curLoc.rawLocation.longitude,\n            }),\n          };\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    return this.etaDeltas;\n  }\n\n  /*\n   * Computes & returns jumps where the vehicle moved\n   * at an unrealistic velocity.\n   */\n  getHighVelocityJumps(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new HighVelocityJump(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.velocityJumps = HighVelocityJump.getSignificantJumps(entries);\n    return this.velocityJumps;\n  }\n\n  /*\n   * Rudimentary dwell location compution.  A lot of issues:\n   *    - Uses size of circle to represent dwell times ... which is confusing\n   *      w.r.t which points make up this cluster. (ie overlapping circles when\n   *      dwell locations are close by).  Should those dwell locations merged?\n   *    - Doesn't compute an actual dwell time, instead assumes UpdateVehicle requests\n   *      are 10 seconds apart\n   *    - A cluster should be within maxDistanceForDwell as well as maxTime in order to be considered\n   *      (right now clusters can be created at a location where multiple trips over days cross)\n   *    - dwell times are fuzzy. Sliders for the time & distance components might be interesting\n   *    - Doesn't respect min/max time filters from the time slider\n   *    - computation of dwell times is slow -- should cache results when turning on & off to avoid\n   *      unnecessary precomputation\n   *    - dwellLocations could be sarted by time to improve cluster lookup\n   *\n   *  See https://stackoverflow.com/questions/36928654/leader-clustering-algorithm-explanation for a\n   *  description of the very simplistic algo used here.\n   */\n  getDwellLocations(minDate, maxDate) {\n    const dwellLocations = [];\n    _.forEach(this.rawLogs, (le) => {\n      const lastLocation = le.lastLocation;\n      if (\n        !lastLocation ||\n        !lastLocation.rawLocation ||\n        le.date < minDate ||\n        le.date > maxDate\n      ) {\n        return;\n      }\n      const coord = {\n        lat: lastLocation.rawLocation.latitude,\n        lng: lastLocation.rawLocation.longitude,\n      };\n      const cluster = _.find(\n        dwellLocations,\n        (dl) =>\n          window.google.maps.geometry.spherical.computeDistanceBetween(\n            dl.leaderCoords,\n            new google.maps.LatLng(coord)\n          ) <= maxDistanceForDwell\n      );\n      if (cluster) {\n        cluster.updates++;\n        cluster.endDate = le.date;\n      } else {\n        dwellLocations.push({\n          leaderCoords: new window.google.maps.LatLng(coord),\n          updates: 1,\n          startDate: le.date,\n        });\n      }\n    });\n\n    this.dwellLocations = _.filter(\n      dwellLocations,\n      (dl) => dl.updates >= requiredUpdatesForDwell\n    );\n\n    return this.dwellLocations;\n  }\n\n  getSegmentID(logEntry) {\n    if (this.solutionType === \"LMFS\") {\n      const stopsLeft = _.get(\n        logEntry,\n        \"jsonPayload.response.remainingVehicleJourneySegments\"\n      );\n      return stopsLeft && \"Stops Left \" + stopsLeft.length;\n    } else {\n      return _.get(logEntry, \"labels.trip_id\");\n    }\n  }\n\n  processTripSegments() {\n    let curTripId = \"this is not a segment\";\n    let curTripData = undefined;\n    let tripIdx = 0;\n    let nonTripIdx = 0;\n    let lastTripStatus = \"no status\";\n    // assumes logs are already sorted\n    // also assumes out-of-order updates can't happen.  Unclear\n    // if this is a good assumption, but it might be worth it to call out\n    // places where it happens (since that might actually be a client bug).\n\n    _.forEach(this.rawLogs, (le) => {\n      if (le.logName.match(this.updateVehicleSuffix)) {\n        const newTripId = this.getSegmentID(le);\n        if (newTripId !== curTripId) {\n          curTripId = newTripId;\n          const tripName = newTripId\n            ? newTripId\n            : \"non-trip-segment-\" + nonTripIdx;\n          curTripData = new Trip(tripIdx, tripName, new Date(le.timestamp));\n          this.trips.push(curTripData);\n          this.trip_ids.push(curTripData.tripName);\n\n          tripIdx++;\n          if (newTripId === undefined) {\n            nonTripIdx++;\n          }\n        } else {\n          curTripData.lastUpdate = new Date(le.timestamp);\n          curTripData.tripDuration =\n            curTripData.lastUpdate - curTripData.firstUpdate;\n          curTripData.updateRequests++;\n        }\n        const lastLocation = _.get(le, this.lastLocationPath);\n        if (lastLocation && lastLocation.rawLocation) {\n          curTripData.appendCoords(lastLocation, le.timestamp);\n        }\n      }\n      const tripStatus = _.get(le, \"jsonPayload.response.status\");\n      // if the logs had a trip status, and it changeed update\n      if (tripStatus && tripStatus !== lastTripStatus) {\n        this.tripStatusChanges.push({\n          newStatus: tripStatus,\n          date: new Date(le.timestamp),\n        });\n        lastTripStatus = tripStatus;\n      }\n    });\n  }\n}\n\nexport { TripLogs as default };\n","/*\n * index.js\n */\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport Map from \"./Map\";\nimport {\n  tripLogs,\n  loadData,\n  apikey,\n  jwt,\n  projectId,\n  solutionType,\n} from \"./vehicleData\";\n\nloadData().then(() => {\n  const logData = {\n    tripLogs,\n    apikey,\n    jwt,\n    projectId,\n    solutionType,\n  };\n  ReactDOM.render(\n    <div>\n      <Map logData={logData} />\n      <App logData={logData} />\n    </div>,\n    document.getElementById(\"root\")\n  );\n});\n"],"sourceRoot":""}