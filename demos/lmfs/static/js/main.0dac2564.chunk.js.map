{"version":3,"sources":["Map.js","queryString.js","Utils.js","Dataframe.js","TimeSlider.js","LogTable.js","ToggleBar.js","App.js","ServeHome.js","Trip.js","Stats.js","HighVelocityJump.js","MissingUpdate.js","TripLogs.js","vehicleData.js","Task.js","TaskLogs.js","index.js"],"names":["minDate","maxDate","map","apikey","mapId","trafficLayer","panorama","jwt","projectId","locationProvider","solutionType","tripLogs","taskLogs","setFeaturedObject","setTimeRange","setQueryStringWithoutPageReload","qsValue","newurl","window","location","protocol","host","pathname","history","pushState","path","getQueryStringValue","key","queryString","search","values","qs","parse","setQueryStringValue","value","newQsValue","stringify","Utils","duration","sec_num","hours","Math","floor","minutes","seconds","timeStr","allPaths","allMarkers","dataMakers","bubbleMap","toggleHandlers","render","status","Status","LOADING","FAILURE","addTripPolys","_","forEach","p","setMap","m","lastVehicleCoords","trips","getTrips","vehicleBounds","google","maps","LatLngBounds","trip","bounds","tripCoords","getPathCoords","length","last","Polyline","geodesic","strokeColor","getColor","tripIdx","strokeOpacity","strokeWeight","event","addListener","setOptions","fd","getFeaturedData","firstUpdate","getTime","lastUpdate","getPath","e","extend","push","lastVehicleLocMark","Marker","position","icon","url","scaledSize","Size","title","MyMapComponent","props","ref","useRef","useEffect","urlZoom","urlCenter","urlTilt","urlHeading","element","journeySharing","FleetEngineTripLocationProvider","authTokenFetcher","options","console","log","token","JourneySharingMapView","mapOptions","mapTypeControl","streetViewControl","ControlPosition","TOP_CENTER","text","amount","controlDiv","document","createElement","controlUI","classList","add","innerText","addEventListener","setTilt","getTilt","appendChild","controls","initializeMapObject","current","setZoom","parseInt","setCenter","JSON","fitBounds","setHeading","maxZoom","getZoom","getHeading","debounce","getCenter","toJSON","Date","rangeStart","rangeEnd","handler","name","data","selectedRow","svgMarker","fillColor","fillOpacity","rotation","scale","anchor","Point","rawLocation","get","lastLocation","state","locationForLog","lat","latitude","lng","longitude","toggles","id","enabled","toggleOptions","style","height","colors","Map","logData","urlParams","URLSearchParams","apiKey","version","libraries","GenerateBubbles","bubbleName","cb","showBubble","bubble","getLogs_","le","rawlocation","lastlocation","undefined","LatLng","compact","rawLocationLatLng","color","locsensor","accuracy","rawlocationaccuracy","circ","Circle","center","radius","logEntry","clientTimeStr","lastlocationResponse","serverTimeStr","clientDate","serverDate","timeDeltaSeconds","abs","heading","headingLine","icons","SymbolPath","FORWARD_CLOSED_ARROW","offset","geometry","spherical","computeOffset","StreetViewPanorama","getElementById","pov","pitch","addressControlOptions","BOTTOM_CENTER","linksControl","panControl","enableCloseButton","speed","tripStatus","getTripStatusAtDate","date","statusCirc","TrafficLayer","dwellLocations","getDwellLocations","dl","leaderCoords","updates","startDate","formatDuration","endDate","tasks","getTasks","getIcon","task","outcome","taskoutcome","match","marker","plannedlocation","point","taskid","trackingid","ret","arrowColor","plannedVsActualDeltaMeters","taskoutcomelocation","offSetPath","flatten","navStatus","vehicleState","etaDeltas","getETADeltas","etaDelta","coords","min","deltaInSeconds","etaDeltaInSeconds","jumps","getHighVelocityJumps","jump","getStrokeWeight","velocity","startLoc","endLoc","jumpIdx","missingUpdates","getMissingUpdates","update","interval","offsetHeading","computeHeading","points","CIRCLE","tripId","getTripIDs","Dataframe","src","featuredObject","onSelect","onClick","Range","createSliderWithTooltip","Slider","width","TimeSlider","marks","getTripStatusChanges","change","minVal","maxVal","curMin","max","curMax","step","onChange","onSliderChange","minTime","maxTime","defaultValue","tipFormatter","d","Styles","styled","div","Table","columns","onSelectionChange","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","row","getRowProps","original","cells","cell","getCellProps","TrimCell","trim","replace","LogTable","timeRange","React","useMemo","stdColumns","filter","Header","accessor","solutionTypes","Cell","sumBy","indexOf","extraColumns","dotPath","elems","split","Button","button","ButtonToggle","active","ButtonGroup","ToggleBar","toggleState","toggle","clickHandler","href","docLink","target","rel","getToggleDefault","urlKey","defaultVal","App","nowDate","urlMinTime","urlMaxTime","initialMinTime","initialMaxTime","setFullYear","getFullYear","msg","showGPSBubbles","showHeading","showSpeed","showTraffic","showTripStatus","showDwellLocations","showNavStatus","showETADeltas","showHighVelocityJumps","showMissingUpdates","showTasksAsCreated","showLiveJS","showClientServerTimeDeltas","onSliderChangeDebounced","bind","this","updateToggleState","newValue","toggleName","jsonPaths","setState","prevState","clone","pull","uniq","select","jsonPath","join","namespace","find","x","without","toggleClickHandler","marginTop","overflowX","overFlowY","float","marginLeft","overFlowX","onDataframePropClick","Component","ServeHome","vehicle","handleVehicleChange","goVehicle","encodeURI","handleTripChange","goTrip","cols","Trip","tripName","updateRequests","pathCoords","tripDuration","creationTime","computeLength","traveledDistanceKilometers","getTraveledDistance","traveledDistanceMiles","timestamp","trip_id","Stats","dataSet","sorted","sort","ceil","computedOutlier","HighVelocityJump","prevEntry","curEntry","prevLoc","curLoc","distanceTraveled","computeDistanceBetween","timeSpentMS","entry","velocityMPH","toString","computedOutlierVelocity","featureData","timestampMS","formattedDate","toISOString","jsonpayload","velocities","avgVelocity","mean","medianVelocity","median","minVelocity","maxVelocity","sortBy","MissingUpdate","idx","startVehicleState","endVehicleState","temporal_gap","response","getStateTransition","intervals","avgInterval","medianInterval","minInterval","maxInterval","toLowerKeys","input","Array","isArray","Object","keys","reduce","newObj","val","newVal","toLowerCase","TripLogs","rawLogs","updateVehicleSuffix","vehiclePath","navStatusPropName","vehicleName","lastLocationPath","trip_ids","tripStatusChanges","reverse","velocityJumps","processTripSegments","getRawLogs_","concat","j","getLogViewerEntry","u","sortedIndexBy","newStatus","entries","getSignificantMissingUpdates","getSignificantJumps","coord","cluster","stopsLeft","curTripId","curTripData","nonTripIdx","lastTripStatus","logname","newTripId","getSegmentID","appendCoords","Task","taskIdx","taskReq","taskResp","taskId","addUpdate","taskInfo","type","taskoutcomelocationsource","taskoutcometime","TaskLogs","processTasks","logs","request","getTaskInfo","dataFileName","fetch","json","parsedData","APIKEY","params","serveMode","ReactDOM","loadData","then"],"mappings":"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","file":"static/js/main.0dac2564.chunk.js","sourcesContent":["/*\n * Map.js\n *\n * Uses the react-wrapper to make using google maps js sdk\n * easier in react.  Beyond basic loading doesn't pretend to\n * act like a normal react component.\n */\nimport { Wrapper, Status } from \"@googlemaps/react-wrapper\";\nimport { useEffect, useRef } from \"react\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\nimport Utils from \"./Utils\";\n\nlet minDate;\nlet maxDate;\nlet allPaths = [];\nlet allMarkers = [];\nlet map;\nlet apikey;\nlet mapId;\nlet dataMakers = [];\nlet trafficLayer;\nconst bubbleMap = {};\nconst toggleHandlers = {};\nlet panorama;\nlet jwt;\nlet projectId;\nlet locationProvider;\nlet solutionType;\nlet tripLogs;\nlet taskLogs;\nlet setFeaturedObject;\nlet setTimeRange;\n\nconst render = (status) => {\n  if (status === Status.LOADING) return <h3>{status} ..</h3>;\n  if (status === Status.FAILURE) return <h3>{status} ...</h3>;\n  return null;\n};\n\nfunction addTripPolys(map) {\n  _.forEach(allPaths, (p) => p.setMap(null));\n  allPaths = [];\n  _.forEach(allMarkers, (m) => m.setMap(null));\n  allMarkers = [];\n\n  const trips = tripLogs.getTrips();\n  const vehicleBounds = new window.google.maps.LatLngBounds();\n  let lastVehicleCoords;\n  _.forEach(trips, (trip) => {\n    const tripCoords = trip.getPathCoords(minDate, maxDate);\n    if (tripCoords.length > 0) {\n      lastVehicleCoords = _.last(tripCoords);\n      const path = new window.google.maps.Polyline({\n        path: tripCoords,\n        geodesic: true,\n        strokeColor: getColor(trip.tripIdx),\n        strokeOpacity: 0.5,\n        strokeWeight: 6,\n      });\n      google.maps.event.addListener(path, \"mouseover\", () => {\n        path.setOptions({\n          strokeOpacity: 1,\n          strokeWeight: 8,\n        });\n      });\n      google.maps.event.addListener(path, \"mouseout\", () => {\n        path.setOptions({\n          strokeOpacity: 0.5,\n          strokeWeight: 6,\n        });\n      });\n      google.maps.event.addListener(path, \"click\", () => {\n        const fd = trip.getFeaturedData();\n        setFeaturedObject(fd);\n        // TODO: https://github.com/googlemaps/fleet-debugger/issues/79\n        // this time range won't capture the createTrip logs\n        setTimeRange(fd.firstUpdate.getTime(), fd.lastUpdate.getTime());\n      });\n      getPolyBounds(vehicleBounds, path);\n      path.setMap(map);\n      allPaths.push(path);\n    }\n  });\n  if (lastVehicleCoords) {\n    const urlBase = \"http://maps.google.com/mapfiles/kml/shapes/\";\n    const lastVehicleLocMark = new window.google.maps.Marker({\n      position: lastVehicleCoords,\n      map: map,\n      icon: {\n        url: urlBase + (solutionType === \"LMFS\" ? \"truck.png\" : \"cabs.png\"),\n        scaledSize: new google.maps.Size(25, 25),\n      },\n      title: \"Last Location\",\n    });\n    allMarkers.push(lastVehicleLocMark);\n  }\n  return vehicleBounds;\n}\n\n/*\n * Creates the map object using a journeySharing location\n * provider.\n */\nfunction initializeMapObject(element) {\n  // In a more normal implementation authTokenFetcher\n  // would actually be making a RPC to a backend to generate\n  // the jwt.  For debugging use cases the jwt gets bundled into\n  // the extracted log data.\n  function authTokenFetcher(options) {\n    // TODO #25 - bake in actual expiration time -- and give a\n    // better error message for expired jwts\n    console.log(\"Ignoring options using prebuilt jwt\", options);\n    const authToken = {\n      token: jwt,\n    };\n    return authToken;\n  }\n\n  locationProvider =\n    new google.maps.journeySharing.FleetEngineTripLocationProvider({\n      projectId,\n      authTokenFetcher,\n    });\n  const jsMapView = new google.maps.journeySharing.JourneySharingMapView({\n    element: element,\n    locationProvider,\n    mapOptions: {\n      mapId: mapId,\n      mapTypeControl: true,\n      streetViewControl: true,\n    },\n  });\n  const map = jsMapView.map;\n\n  const tiltButtons = [\n    [\"Tilt Down\", 20, google.maps.ControlPosition.TOP_CENTER],\n    [\"Tilt Up\", -20, google.maps.ControlPosition.TOP_CENTER],\n  ];\n\n  tiltButtons.forEach(([text, amount, position]) => {\n    const controlDiv = document.createElement(\"div\");\n    const controlUI = document.createElement(\"button\");\n\n    controlUI.classList.add(\"ui-button\");\n    controlUI.innerText = `${text}`;\n    controlUI.addEventListener(\"click\", () => {\n      map.setTilt(map.getTilt() + amount);\n    });\n    controlDiv.appendChild(controlUI);\n    map.controls[position].push(controlDiv);\n  });\n  return map;\n}\n\nfunction MyMapComponent(props) {\n  const ref = useRef();\n\n  useEffect(() => {\n    const urlZoom = getQueryStringValue(\"zoom\");\n    const urlCenter = getQueryStringValue(\"center\");\n    const urlTilt = getQueryStringValue(\"tilt\");\n    const urlHeading = getQueryStringValue(\"heading\");\n    map = initializeMapObject(ref.current);\n    const vehicleBounds = addTripPolys(map);\n    if (urlZoom && urlCenter) {\n      console.log(\"setting zoom & center from url\", urlZoom, urlCenter);\n      map.setZoom(parseInt(urlZoom));\n      map.setCenter(JSON.parse(urlCenter));\n    } else {\n      map.fitBounds(vehicleBounds);\n    }\n\n    if (urlTilt) {\n      map.setTilt(parseInt(urlTilt));\n    }\n    if (urlHeading) {\n      map.setHeading(parseInt(urlHeading));\n    }\n    map.setOptions({ maxZoom: 100 });\n    map.addListener(\"zoom_changed\", () => {\n      setQueryStringValue(\"zoom\", map.getZoom());\n    });\n\n    map.addListener(\"tilt_changed\", () => {\n      setQueryStringValue(\"tilt\", map.getTilt());\n    });\n\n    map.addListener(\"heading_changed\", () => {\n      setQueryStringValue(\"heading\", map.getHeading());\n    });\n\n    map.addListener(\n      \"center_changed\",\n      _.debounce(() => {\n        setQueryStringValue(\"center\", JSON.stringify(map.getCenter().toJSON()));\n      }, 100)\n    );\n  }, []);\n\n  /*\n   * Handler for timewindow change.  Updates global min/max date globals\n   * and recomputes the paths as well as all the bubble markers to respect the\n   * new date values.\n   *\n   * Debounced to every 100ms as a blance between performance and reactivity when\n   * the slider is dragged.\n   */\n  useEffect(\n    () =>\n      _.debounce(() => {\n        minDate = new Date(props.rangeStart);\n        maxDate = new Date(props.rangeEnd);\n        addTripPolys(map);\n        _.forEach(toggleHandlers, (handler, name) => {\n          if (bubbleMap[name]) {\n            handler(true);\n          }\n        });\n      }, 100),\n    [props.rangeStart, props.rangeEnd]\n  );\n\n  useEffect(() => {\n    const data = props.selectedRow;\n    if (!data) return;\n    _.forEach(dataMakers, (m) => m.setMap(null));\n    dataMakers = [];\n    const svgMarker = {\n      path: \"M10.453 14.016l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM12 2.016q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z\",\n      fillColor: \"blue\",\n      fillOpacity: 0.6,\n      strokeWeight: 0,\n      rotation: 0,\n      scale: 2,\n      anchor: new google.maps.Point(15, 30),\n    };\n\n    const rawLocation = _.get(data.lastLocation, \"rawLocation\");\n    if (rawLocation) {\n      const status = _.get(data, \"jsonPayload.response.status\");\n      const state = _.get(data, \"jsonPayload.response.state\");\n      const locationForLog = new window.google.maps.Marker({\n        position: { lat: rawLocation.latitude, lng: rawLocation.longitude },\n        map: map,\n        icon: svgMarker,\n        title: \"Vehicle state \" + state + \" Trip Status \" + status,\n      });\n      dataMakers.push(locationForLog);\n    }\n    // TODO: for non-vehicle api calls could attempt to interpolate the location\n  }, [props.selectedRow]);\n\n  for (const toggle of props.toggles) {\n    const id = toggle.id;\n    const enabled = props.toggleOptions[id];\n    useEffect(() => {\n      toggleHandlers[id](enabled);\n    }, [props.toggleOptions[id]]);\n  }\n\n  return <div ref={ref} id=\"map\" style={{ height: \"500px\" }} />;\n}\n\nfunction getPolyBounds(bounds, p) {\n  p.getPath().forEach((e) => {\n    bounds.extend(e);\n  });\n  return bounds;\n}\n\n/*\n * Deterministically assign a color per trip using tripIdx\n * Colors were chosen for visibility\n */\nfunction getColor(tripIdx) {\n  const colors = [\n    \"#2d7dd2\",\n    \"#97cc04\",\n    \"#eeb902\",\n    \"#f45d01\",\n    \"#474647\",\n    \"00aa00\",\n  ];\n  return colors[tripIdx % colors.length];\n}\n\nfunction Map(props) {\n  tripLogs = props.logData.tripLogs;\n  taskLogs = props.logData.taskLogs;\n  minDate = tripLogs.minDate;\n  maxDate = tripLogs.maxDate;\n  const urlParams = new URLSearchParams(window.location.search);\n  apikey = urlParams.get(\"apikey\") || props.logData.apikey;\n  mapId = urlParams.get(\"mapId\") || props.logData.mapId;\n  jwt = props.logData.jwt;\n  projectId = props.logData.projectId;\n  solutionType = props.logData.solutionType;\n  setFeaturedObject = props.setFeaturedObject;\n  setTimeRange = props.setTimeRange;\n\n  return (\n    <Wrapper\n      apiKey={apikey}\n      render={render}\n      version=\"beta\"\n      libraries={[\"geometry\", \"journeySharing\"]}\n    >\n      <MyMapComponent\n        rangeStart={props.rangeStart}\n        rangeEnd={props.rangeEnd}\n        selectedRow={props.selectedRow}\n        toggles={props.toggles}\n        toggleOptions={props.toggleOptions}\n      />\n    </Wrapper>\n  );\n}\n\n/*\n * GenerateBubbles() -- helper function for generating map features based\n * on per-log entry data.\n *\n * Handles the gunk of iterating over log entries and clearing/setting the map\n */\nfunction GenerateBubbles(bubbleName, cb) {\n  return (showBubble) => {\n    _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n    delete bubbleMap[bubbleName];\n    if (showBubble) {\n      bubbleMap[bubbleName] = tripLogs\n        .getLogs_(minDate, maxDate)\n        .map((le) => {\n          const lastLocation = le.lastlocation;\n          let rawlocation;\n          let bubble = undefined;\n          if (lastLocation && (rawlocation = lastLocation.rawlocation)) {\n            bubble = cb(\n              new google.maps.LatLng({\n                lat: rawlocation.latitude,\n                lng: rawlocation.longitude,\n              }),\n              lastLocation,\n              le\n            );\n          }\n          return bubble;\n        })\n        .compact()\n        .value();\n    }\n  };\n}\n\n/*\n * Draws circles on map with a radius equal to the\n * GPS accuracy.\n */\ntoggleHandlers[\"showGPSBubbles\"] = GenerateBubbles(\n  \"showGPSBubbles\",\n  (rawLocationLatLng, lastLocation) => {\n    let color;\n    switch (lastLocation.locsensor) {\n      case \"LOCATION_SENSOR_GPS\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_NETWORK\":\n        color = \"#FF1111\";\n        break;\n      case \"LOCATION_SENSOR_PASSIVE\":\n        color = \"#FF0000\";\n        break;\n      case \"LOCATION_SENSOR_ROAD_SNAPPED_LOCATION_PROVIDER\":\n        color = \"#00FF00\";\n        break;\n      case \"LOCATION_SENSOR_FUSED_LOCATION_PROVIDER\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_LOG_UNSPECIFIED\":\n      default:\n        color = \"#000000\";\n    }\n    const accuracy = lastLocation.rawlocationaccuracy;\n    if (accuracy) {\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: accuracy, // units is this actually meters?\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          rawlocationaccuracy: lastLocation.rawlocationaccuracy,\n          locsensor: lastLocation.locsensor,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws circles on map with a radius equal to the\n * time delta (1 meter radius = 1 second of delta)\n */\ntoggleHandlers[\"showClientServerTimeDeltas\"] = GenerateBubbles(\n  \"showClientServerTimeDeltas\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    const clientTimeStr = _.get(\n      logEntry.lastlocationResponse,\n      \"rawlocationtime\"\n    );\n    const serverTimeStr = _.get(logEntry.lastlocationResponse, \"servertime\");\n    if (clientTimeStr && serverTimeStr) {\n      const clientDate = new Date(clientTimeStr);\n      const serverDate = new Date(serverTimeStr);\n      const timeDeltaSeconds =\n        Math.abs(clientDate.getTime() - serverDate.getTime()) / 1000;\n      let color;\n      if (clientDate > serverDate) {\n        color = \"#0000F0\";\n      } else {\n        color = \"#0F0000\";\n      }\n\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: timeDeltaSeconds,\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          timeDeltaSeconds: timeDeltaSeconds,\n          serverDate: serverDate,\n          clientDate: clientDate,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws arrows on map showing the measured heading\n * of the vehicle (ie which direction vehicle was traveling\n */\ntoggleHandlers[\"showHeading\"] = GenerateBubbles(\n  \"showHeading\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    // Note: Heading & accuracy are only on the _request_ not the\n    // response.\n    const heading = _.get(logEntry.lastlocation, \"heading\");\n    const accuracy = _.get(logEntry.lastlocation, \"bearingaccuracy\");\n\n    // Not currently using accuracy. How to show it?  Maybe opacity of the arrorw?\n    const arrowLength = 20; // meters??\n    if (!(heading && accuracy)) {\n      return;\n    }\n    const headingLine = new google.maps.Polyline({\n      strokeColor: \"#0000F0\",\n      strokeOpacity: 0.6,\n      strokeWeight: 2,\n      icons: [\n        {\n          icon: {\n            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n            strokeColor: \"#0000FF\",\n            strokeWeight: 4,\n          },\n          offset: \"100%\",\n        },\n      ],\n      map,\n      path: [\n        rawLocationLatLng,\n        google.maps.geometry.spherical.computeOffset(\n          rawLocationLatLng,\n          arrowLength,\n          heading\n        ),\n      ],\n    });\n    google.maps.event.addListener(headingLine, \"click\", () => {\n      // TODO: allow updating panorama based on forward/back\n      // stepper buttons (ie at each updatevehicle log we have a heading)\n      panorama = new google.maps.StreetViewPanorama(\n        document.getElementById(\"map\"),\n        {\n          position: rawLocationLatLng,\n          pov: { heading: heading, pitch: 10 },\n          addressControlOptions: {\n            position: google.maps.ControlPosition.BOTTOM_CENTER,\n          },\n          linksControl: false,\n          panControl: false,\n          enableCloseButton: true,\n        }\n      );\n      console.log(\"loaded panorama\", panorama);\n    });\n    return headingLine;\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates vehicle speed at that\n * location.\n */\ntoggleHandlers[\"showSpeed\"] = GenerateBubbles(\n  \"showSpeed\",\n  (rawLocationLatLng, lastLocation) => {\n    const speed = lastLocation.speed;\n    if (lastLocation.speed === undefined) {\n      return;\n    }\n    const color = speed < 0 ? \"#FF0000\" : \"#00FF00\";\n    return new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: Math.abs(speed),\n    });\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates trip status\n * at that location.   Note that trip status isn't actually\n * in the update vehicle logs, so current trip status will actually\n * just be the trip status at the time of the vehicle update  --\n * which is a bit wrong and wonky on the boundaries.\n */\ntoggleHandlers[\"showTripStatus\"] = GenerateBubbles(\n  \"showTripStatus\",\n  (rawLocationLatLng, lastLocation, le) => {\n    let color,\n      radius = 5;\n    const tripStatus = tripLogs.getTripStatusAtDate(le.date);\n    switch (tripStatus) {\n      case \"TRIP_STATUS_NEW\":\n        color = \"#002200\";\n        radius = 30;\n        break;\n      case \"TRIP_STATUS_ENROUTE_TO_PICKUP\":\n        color = \"#FFFF00\";\n        break;\n      case \"TRIP_STATUS_ARRIVED_AT_PICKUP\":\n        color = \"#FFFF10\";\n        radius = 10;\n        break;\n      case \"TRIP_STATUS_ARRIVED_AT_INTERMEDIATE_DESTINATION\":\n        color = \"10FFFF\";\n        radius = 20;\n        break;\n      case \"TRIP_STATUS_ENROUTE_TO_DROPOFF\":\n        color = \"00FFFF\";\n        break;\n      case \"TRIP_STATUS_COMPLETE\":\n        radius = 30;\n        color = \"#00FF00\";\n        break;\n      case \"TRIP_STATUS_CANCELED\":\n        radius = 30;\n        color = \"#FF0000\";\n        break;\n      case \"TRIP_STATUS_UNKNOWN_TRIP_STATUS\":\n      default:\n        color = \"#000000\";\n    }\n\n    const statusCirc = new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: radius, // set based on trip status?\n    });\n    google.maps.event.addListener(statusCirc, \"mouseover\", () => {\n      setFeaturedObject({\n        tripStatus: tripStatus,\n      });\n    });\n    return statusCirc;\n  }\n);\n\n/*\n * Enable/disables live traffic layer\n */\ntoggleHandlers[\"showTraffic\"] = function (enabled) {\n  if (!trafficLayer) {\n    trafficLayer = new google.maps.TrafficLayer();\n  }\n  if (enabled) {\n    trafficLayer.setMap(map);\n  } else {\n    trafficLayer.setMap(null);\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showDwellLocations\"] = function (enabled) {\n  const bubbleName = \"showDwellLocations\";\n  const dwellLocations = tripLogs.getDwellLocations(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(dwellLocations, (dl) => {\n      const circ = new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"#FFFF00\",\n        fillOpacity: 0.25,\n        map,\n        center: dl.leaderCoords,\n        radius: dl.updates * 3, // make dwell times more obvious\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          startDate: dl.startDate,\n          duration: Utils.formatDuration(dl.endDate - dl.startDate),\n          endDate: dl.endDate,\n        });\n      });\n      return circ;\n    });\n  }\n};\n\n/*\n * Draws markers on the map for all tasks.\n */\ntoggleHandlers[\"showTasksAsCreated\"] = function (enabled) {\n  const bubbleName = \"showTasksAsCreated\";\n  const tasks = taskLogs.getTasks(maxDate).value();\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  function getIcon(task) {\n    const outcome = task.taskoutcome || \"unknown\";\n    const urlBase = \"http://maps.google.com/mapfiles/kml/shapes/\";\n    const icon = {\n      url: urlBase,\n      scaledSize: new google.maps.Size(35, 35),\n    };\n    if (outcome.match(\"SUCCEEDED\")) {\n      icon.url += \"flag.png\";\n    } else if (outcome.match(\"FAIL\")) {\n      icon.url += \"caution.png\";\n    } else {\n      icon.url += \"shaded_dot.png\";\n    }\n    return icon;\n  }\n  if (enabled) {\n    bubbleMap[bubbleName] = _(tasks)\n      .map((task) => {\n        const marker = new window.google.maps.Marker({\n          position: {\n            lat: task.plannedlocation.point.latitude,\n            lng: task.plannedlocation.point.longitude,\n          },\n          map: map,\n          icon: getIcon(task),\n          title: `${task.state}: ${task.taskid} - ${task.trackingid}`,\n        });\n        google.maps.event.addListener(marker, \"click\", () => {\n          setFeaturedObject(task);\n        });\n        const ret = [marker];\n        const arrowColor =\n          task.plannedVsActualDeltaMeters > 50 ? \"#FF1111\" : \"#11FF11\";\n        if (task.taskoutcomelocation) {\n          const offSetPath = new window.google.maps.Polyline({\n            path: [\n              {\n                lat: task.plannedlocation.point.latitude,\n                lng: task.plannedlocation.point.longitude,\n              },\n              {\n                lat: task.taskoutcomelocation.point.latitude,\n                lng: task.taskoutcomelocation.point.longitude,\n              },\n            ],\n            geodesic: true,\n            strokeColor: arrowColor,\n            strokeOpacity: 0.6,\n            strokeWeight: 4,\n            map: map,\n            icons: [\n              {\n                icon: {\n                  path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                  strokeColor: arrowColor,\n                  strokeWeight: 4,\n                },\n                offset: \"100%\",\n              },\n            ],\n          });\n          ret.push(offSetPath);\n        }\n        return ret;\n      })\n      .flatten()\n      .value();\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showNavStatus\"] = GenerateBubbles(\n  \"showNavStatus\",\n  (rawLocationLatLng, lastLocation, le) => {\n    const navStatus = le.navStatus;\n    if (navStatus === undefined) {\n      return;\n    }\n    let color,\n      radius = 5;\n    switch (navStatus) {\n      case \"NAVIGATION_STATUS_UNKNOWN_NAVIGATION_STATUS\":\n        color = \"#222222\";\n        break;\n      case \"NAVIGATION_STATUS_NO_GUIDANCE\":\n        color = \"#090909\";\n        break;\n      case \"NAVIGATION_STATUS_ENROUTE_TO_DESTINATION\":\n        color = \"#00FF00\";\n        break;\n      case \"NAVIGATION_STATUS_OFF_ROUTE\":\n        color = \"#FF0000\";\n        radius = 30;\n        break;\n      case \"NAVIGATION_STATUS_ARRIVED_AT_DESTINATION\":\n        color = \"0000FF\";\n        radius = 10;\n        break;\n      default:\n        color = \"#000000\";\n    }\n    const statusCirc = new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: radius, // set based on trip status?\n    });\n    google.maps.event.addListener(statusCirc, \"mouseover\", () => {\n      setFeaturedObject({\n        navStatus: navStatus,\n        vehicleState: _.get(le, \"jsonpayload.response.state\"),\n        tripStatus: \"??\",\n      });\n    });\n    return statusCirc;\n  }\n);\n\n/*\n * Draws circles on the map. Size indicates delta in seconds at that\n * location.\n */\ntoggleHandlers[\"showETADeltas\"] = function (enabled) {\n  const bubbleName = \"showETADeltas\";\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  const etaDeltas = tripLogs.getETADeltas(minDate, maxDate);\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(etaDeltas, (etaDelta) => {\n      const circ = new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"FF0000\",\n        fillOpacity: 0.25,\n        map,\n        center: etaDelta.coords,\n        // cap radius to 300 meters to avoid coloring the whole\n        // screen when there is a very large delta.  Definitely\n        // needs tuning ... and likely better to consider adjusting\n        // color as well.\n        radius: _.min([etaDelta.deltaInSeconds, 300]),\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          etaDeltaInSeconds: etaDelta.deltaInSeconds,\n        });\n      });\n      return circ;\n    });\n  }\n};\n\n/*\n * Draws arrows on the map showing where a vehicle jumped\n * from one location to another at an unrealistic velocity.\n */\ntoggleHandlers[\"showHighVelocityJumps\"] = function (enabled) {\n  const bubbleName = \"showHighVelocityJumps\";\n  const jumps = tripLogs.getHighVelocityJumps(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(jumps)\n      .map((jump) => {\n        function getStrokeWeight(velocity) {\n          if (velocity <= 100) {\n            return 2;\n          } else if (velocity < 1000) {\n            return 6;\n          } else if (velocity < 2000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const path = new window.google.maps.Polyline({\n          path: [jump.startLoc, jump.endLoc],\n          geodesic: true,\n          strokeColor: getColor(jump.jumpIdx),\n          strokeOpacity: 0.8,\n          strokeWeight: getStrokeWeight(jump.velocity),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: getColor(jump.jumpIdx),\n                strokeWeight: getStrokeWeight(jump.velocity),\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n          // show a minute +/- on each side of a jump\n          setTimeRange(\n            jump.startDate.getTime() - 60 * 1000,\n            jump.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Marks locations on the map where we did not get the expected\n * updateVehicle requests\n */\ntoggleHandlers[\"showMissingUpdates\"] = function (enabled) {\n  const bubbleName = \"showMissingUpdates\";\n  const missingUpdates = tripLogs.getMissingUpdates(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(missingUpdates)\n      .map((update) => {\n        function getStrokeWeight(interval) {\n          if (interval <= 60 * 1000) {\n            return 2;\n          } else if (interval < 60 * 10 * 1000) {\n            return 6;\n          } else if (interval < 60 * 60 * 10 * 1000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const heading = google.maps.geometry.spherical.computeHeading(\n          update.startLoc,\n          update.endLoc\n        );\n        const offsetHeading = ((heading + 360 + 90) % 360) - 180;\n        const points = [\n          update.startLoc,\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          update.endLoc,\n        ];\n        const path = new window.google.maps.Polyline({\n          path: points,\n          geodesic: true,\n          strokeColor: \"#008B8B\",\n          strokeOpacity: 0.5,\n          strokeWeight: getStrokeWeight(update.interval),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: \"#008B8B\",\n                strokeWeight: getStrokeWeight(update.interval),\n                scale: 6,\n              },\n              offset: \"50%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"0%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          path.setOptions({\n            strokeOpacity: 1,\n            strokeWeight: 1.5 * getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"mouseout\", () => {\n          path.setOptions({\n            strokeOpacity: 0.5,\n            strokeWeight: getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          // show a minute +/- on each side of a update\n          setTimeRange(\n            update.startDate.getTime() - 60 * 1000,\n            update.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Enable/disables live journey sharing view\n */\ntoggleHandlers[\"showLiveJS\"] = function (enabled) {\n  if (!jwt) {\n    console.log(\"Issue #25 -- no/invalid jwt\");\n    return;\n  }\n  // call into js to set the trip\n  if (enabled) {\n    locationProvider.tripId = _.last(tripLogs.getTripIDs());\n  } else {\n    locationProvider.tripId = \"\";\n  }\n};\n\nexport { Map as default };\n","import qs from \"query-string\";\n\nconst setQueryStringWithoutPageReload = (qsValue) => {\n  const newurl =\n    window.location.protocol +\n    \"//\" +\n    window.location.host +\n    window.location.pathname +\n    qsValue;\n  window.history.pushState({ path: newurl }, \"\", newurl);\n};\n\nexport const getQueryStringValue = (\n  key,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  return values[key];\n};\n\nexport const setQueryStringValue = (\n  key,\n  value,\n  queryString = window.location.search\n) => {\n  const values = qs.parse(queryString);\n  const newQsValue = qs.stringify({\n    ...values,\n    [key]: value,\n  });\n  setQueryStringWithoutPageReload(`?${newQsValue}`);\n};\n","class Utils {\n  /*\n   * Formats a duration into something friendly\n   * for human consumption.\n   */\n  static formatDuration(duration) {\n    let sec_num = duration / 1000;\n    let hours = Math.floor(sec_num / 3600);\n    let minutes = Math.floor((sec_num - hours * 3600) / 60);\n    let seconds = Math.floor(sec_num - hours * 3600 - minutes * 60);\n    let timeStr = \"\";\n\n    if (hours > 0) {\n      timeStr += hours + \" hours \";\n    }\n    if (minutes > 0) {\n      timeStr += minutes + \" minutes \";\n    }\n    if (seconds > 0) {\n      timeStr += seconds + \" seconds\";\n    }\n    return timeStr;\n  }\n}\nexport { Utils as default };\n","/*\n * Dataframe.js\n *\n * JSON viewer for log entries.   Clicking on a property _value_\n * adds it to the log viewer.\n *\n * TODO: support clicking on the property name as well, or support an\n * icon or other UI element (similar to copy to clip board).\n */\nimport ReactJson from \"react-json-view\";\nfunction Dataframe(props) {\n  return <ReactJson src={props.featuredObject} onSelect={props.onClick} />;\n}\n\n// TODO: Ideas: allow selecting a field and see how it changes along the map\n// or the slider (ie view on map / view on slider)\n// or 'add slider' that instantiates a slider that has marks\n// when that value changes\nexport default Dataframe;\n","/*\n * TimeSlider.js\n *\n * Provides a time-based visualaziton of key events (vehicle status changes) as well\n * as filtering control for the log viewer & map view.\n *\n * TODO: not clear that rc-slider is actually the correct/best component for this\n * functionality\n */\nimport Slider from \"rc-slider\";\nimport \"rc-slider/assets/index.css\";\nimport _ from \"lodash\";\n\nconst { createSliderWithTooltip } = Slider;\nconst Range = createSliderWithTooltip(Slider.Range);\n\nconst style = { width: \"100%\" };\n\nfunction TimeSlider(props) {\n  const tripLogs = props.logData.tripLogs;\n  const marks = {};\n\n  // Add marks showing when trip status changed.\n  // Ideally label by trip status change ... but labels overrun & look ugly\n  _.map(tripLogs.getTripStatusChanges(), (change) => {\n    marks[change.date.getTime()] = {};\n  });\n\n  const minVal = tripLogs.minDate.getTime();\n  const maxVal = tripLogs.maxDate.getTime();\n\n  const curMin = _.max([minVal, props.curMin]);\n  const curMax = _.min([maxVal, props.curMax]);\n\n  function onChange(value) {\n    props.onSliderChange({\n      minTime: value[0],\n      maxTime: value[1],\n    });\n  }\n\n  function formatTooltip(value) {\n    const d = new Date(value);\n    const tripStatus = tripLogs.getTripStatusAtDate(new Date(value));\n    return `${d}${tripStatus}`;\n  }\n\n  return (\n    <div style={style}>\n      <Range\n        min={minVal}\n        max={maxVal}\n        marks={marks}\n        step={1}\n        onChange={onChange}\n        defaultValue={[minVal, maxVal]}\n        value={[curMin, curMax]}\n        tipFormatter={formatTooltip}\n      />\n    </div>\n  );\n}\n\nexport default TimeSlider;\n","/*\n * LogTable.js\n *\n * Handles the log viewing component.\n */\nimport { useTable } from \"react-table\";\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\n\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n  }\n`;\n\nfunction Table({ columns, data, onSelectionChange }) {\n  const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } =\n    useTable({\n      columns,\n      data,\n    });\n\n  return (\n    <table {...getTableProps()}>\n      <thead>\n        {headerGroups.map((headerGroup) => (\n          <tr {...headerGroup.getHeaderGroupProps()}>\n            {headerGroup.headers.map((column) => (\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\n            ))}\n          </tr>\n        ))}\n      </thead>\n      <tbody {...getTableBodyProps()}>\n        {rows.map((row) => {\n          prepareRow(row);\n          return (\n            <tr\n              {...row.getRowProps()}\n              onClick={() => onSelectionChange(row.original)}\n            >\n              {row.cells.map((cell) => {\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\n              })}\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\n/*\n * Helper method for removing common substrings in cells.  Typically\n * used for removing a prefix from ENUMs.\n */\nconst TrimCell = ({ value, trim }) => {\n  return <>{value && value.replace(trim, \"\")}</>;\n};\n\nfunction LogTable(props) {\n  const minTime = props.timeRange.minTime;\n  const maxTime = props.timeRange.maxTime;\n  const data = props.logData.tripLogs\n    .getLogs_(new Date(minTime), new Date(maxTime))\n    .value();\n\n  const columns = React.useMemo(() => {\n    const stdColumns = _.filter(\n      [\n        {\n          Header: \"Date\",\n          accessor: \"formattedDate\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"SDK Version\",\n          accessor: \"jsonpayload.request.header.sdkversion\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"OS Version\",\n          accessor: \"jsonpayload.request.header.osversion\",\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"Method\",\n          accessor: \"jsonpayload.@type\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell\n              value={value}\n              trim=\"type.googleapis.com/maps.fleetengine.\"\n            />\n          ),\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          Header: \"Vehicle\",\n          accessor: \"labels.vehicle_id\",\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Vehicle\",\n          accessor: \"labels.delivery_vehicle_id\",\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Trip\",\n          accessor: \"labels.trip_id\",\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Vehicle State\",\n          accessor: \"jsonpayload.response.state\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"VEHICLE_STATE_\" />\n          ),\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Task State\",\n          accessor: \"jsonpayload.response.state\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"TASK_STATE_\" />\n          ),\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Trip Status\",\n          accessor: \"jsonpayload.response.status\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"TRIP_STATUS_\" />\n          ),\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          Header: \"Remaining tasks\",\n          id: \"reamining_tasks\",\n          accessor: \"jsonpayload.response.remainingvehiclejourneysegments\",\n          Cell: ({ cell: { value } }) => (\n            <>{value && _.sumBy(value, \"stop.tasks.length\")}</>\n          ),\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Remaining Distance This Segment\",\n          accessor:\n            \"jsonpayload.request.deliveryvehicle.remainingdistancemeters\",\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Remaining Segements\",\n          accessor: \"jsonpayload.response.remainingvehiclejourneysegments\",\n          Cell: ({ cell: { value } }) => <>{value && value.length}</>,\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          Header: \"Nav Status\",\n          // XXX request or response best?\n          accessor: \"navStatus\",\n          Cell: ({ cell: { value } }) => (\n            <TrimCell value={value} trim=\"NAVIGATION_STATUS_\" />\n          ),\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n      ],\n      (column) => {\n        return column.solutionTypes.indexOf(props.logData.solutionType) !== -1;\n      }\n    );\n\n    // Add dynamic columns\n    _.map(props.extraColumns, (dotPath) => {\n      const elems = dotPath.split(\".\");\n      stdColumns.push({\n        Header: elems[elems.length - 1],\n        accessor: dotPath,\n      });\n    });\n    const headers = [\n      {\n        Header: \"Log Entries (click row to view full log entry)\",\n        columns: stdColumns,\n      },\n    ];\n    return headers;\n  }, [props.extraColumns]);\n\n  return (\n    <Styles>\n      <Table\n        columns={columns}\n        data={data}\n        onSelectionChange={props.onSelectionChange}\n      />\n    </Styles>\n  );\n}\n\nexport { LogTable as default };\n","/*\n * ToggleBar.js\n *\n * Row of buttons that configure visualization options on the map\n */\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\nconst Button = styled.button``;\nconst ButtonToggle = styled(Button)`\n  opacity: 0.6;\n  ${({ active }) =>\n    active &&\n    `\n    opacity: 1;\n    color: Green;\n  `}\n`;\n\nconst ButtonGroup = styled.div`\n  display: flex;\n`;\nfunction ToggleBar(props) {\n  const toggleState = props.toggleState;\n  const toggles = _.map(props.toggles, (toggle) => {\n    return (\n      <ButtonToggle\n        key={toggle.id}\n        active={toggleState[toggle.id]}\n        onClick={() => props.clickHandler(toggle.id)}\n      >\n        {toggle.name}\n        <a href={toggle.docLink} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n    );\n  });\n  return <ButtonGroup>{toggles}</ButtonGroup>;\n}\n\nexport default ToggleBar;\n","/*\n * App.js\n *\n * Basic react app container.  Handles state for the app and\n * propagation for state changes into the non-react map\n */\nimport React from \"react\";\nimport Map from \"./Map\";\nimport Dataframe from \"./Dataframe\";\nimport TimeSlider from \"./TimeSlider\";\nimport LogTable from \"./LogTable\";\nimport ToggleBar from \"./ToggleBar\";\nimport _ from \"lodash\";\nimport { getQueryStringValue, setQueryStringValue } from \"./queryString\";\n\n/**\n * returns the default value for the button from the url\n */\nfunction getToggleDefault(urlKey, defaultVal) {\n  const urlVal = getQueryStringValue(urlKey);\n  if (urlVal === \"true\") {\n    defaultVal = true;\n  }\n  return defaultVal;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    const nowDate = new Date();\n    let urlMinTime = getQueryStringValue(\"minTime\");\n    let urlMaxTime = getQueryStringValue(\"maxTime\");\n    this.initialMinTime = urlMinTime ? parseInt(urlMinTime) : 0;\n    // default max time to 1 year in the future\n    this.initialMaxTime = urlMaxTime\n      ? parseInt(urlMaxTime)\n      : nowDate.setFullYear(nowDate.getFullYear() + 1);\n\n    this.state = {\n      timeRange: {\n        minTime: this.initialMinTime,\n        maxTime: this.initialMaxTime,\n      },\n      featuredObject: { msg: \"Click a table row to select object\" },\n      extraColumns: [],\n      toggleOptions: {\n        showGPSBubbles: getToggleDefault(\"showGPSBubbles\", false),\n        showHeading: getToggleDefault(\"showHeading\", false),\n        showSpeed: getToggleDefault(\"showSpeed\", false),\n        showTraffic: getToggleDefault(\"showTraffic\", false),\n        showTripStatus: getToggleDefault(\"showTripStatus\", false),\n        showDwellLocations: getToggleDefault(\"showDwellLocations\", false),\n        showNavStatus: getToggleDefault(\"showNavStatus\", false),\n        showETADeltas: getToggleDefault(\"showETADeltas\", false),\n        showHighVelocityJumps: getToggleDefault(\"showHighVelocityJumps\", false),\n        showMissingUpdates: getToggleDefault(\"showMissingUpdates\", false),\n        showTasksAsCreated: getToggleDefault(\"showTasksAsCreated\", false),\n        showLiveJS: getToggleDefault(\"showLiveJS\", false),\n        showClientServerTimeDeltas: getToggleDefault(\n          \"showClientServerTimeDeltas\",\n          false\n        ),\n      },\n    };\n    // Realtime updates are too heavy.  There must be a better/ react way\n    this.onSliderChangeDebounced = _.debounce(\n      (timeRange) => this.onSliderChange(timeRange),\n      25\n    );\n\n    // TODO: refactor so that visualizations are registered\n    // rather than enumerated here?\n    this.toggles = _.filter(\n      [\n        {\n          id: \"showGPSBubbles\",\n          name: \"GPS Accuracy\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/GPSAccuracy.md\",\n          columns: [\n            \"lastlocation.rawlocationaccuracy\",\n            \"lastlocation.locsensor\",\n          ],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showHeading\",\n          name: \"Heading\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Heading.md\",\n          columns: [\"lastlocation.heading\", \"lastlocation.bearingaccuracy\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showSpeed\",\n          name: \"Speed\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Speed.md\",\n          columns: [\"lastlocation.speed\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showTripStatus\",\n          name: \"Trip Status\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/TripStatus.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          id: \"showNavStatus\",\n          name: \"Navigation Status\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/NavStatus.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showTasksAsCreated\",\n          name: \"Tasks\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Tasks.md\",\n          columns: [],\n          solutionTypes: [\"LMFS\"],\n        },\n        {\n          id: \"showDwellLocations\",\n          name: \"Dwell Locations\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/DwellTimes.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showHighVelocityJumps\",\n          name: \"Jumps (unrealistic velocity)\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/VelocityJumps.md\",\n          columns: [\"lastlocation.speed\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showMissingUpdates\",\n          name: \"Jumps (Temporal)\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/MissingUpdates.md\",\n          columns: [\"jsonpayload.temporal_gap\"],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showClientServerTimeDeltas\",\n          name: \"Client/Server Time Deltas\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [\n            \"jsonpayload.response.laslLocation.rawlocationlime\",\n            \"jsonpayload.response.laslLocation.serverlime\",\n          ],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showETADeltas\",\n          name: \"ETA Deltas\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/EtaDeltas.md\",\n          columns: [\"jsonpayload.request.vehicle.etatofirstwaypoint\"],\n          solutionTypes: [\"ODRD\"],\n        },\n        {\n          id: \"showTraffic\",\n          name: \"Traffic\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n        {\n          id: \"showLiveJS\",\n          name: \"Start Live Journey Sharing for newest trip\",\n          docLink:\n            \"https://github.com/googlemaps/fleet-debugger/blob/main/README.md\",\n          columns: [],\n          solutionTypes: [\"ODRD\", \"LMFS\"],\n        },\n      ],\n      (toggle) => {\n        return (\n          toggle.solutionTypes.indexOf(this.props.logData.solutionType) !== -1\n        );\n      }\n    );\n    this.setFeaturedObject = this.setFeaturedObject.bind(this);\n    this.setTimeRange = this.setTimeRange.bind(this);\n  }\n\n  /*\n   * Update react state from data in the url.  This could/should be\n   * cleaned up.  The pure react state is actually set properly in the\n   * constructor ... all this does is update the map and associated\n   * data (once it's loaded).  Given this split it's definitely possible\n   * that this just overwrites settings a quickfingered user already\n   * changed.\n   */\n  componentDidMount() {\n    this.setTimeRange(this.initialMinTime, this.initialMaxTime);\n    _.map(this.toggles, (toggle) => {\n      const urlVal = getQueryStringValue(toggle.id);\n      if (urlVal === \"true\") {\n        this.updateToggleState(true, toggle.id, toggle.columns);\n      }\n    });\n  }\n\n  updateToggleState(newValue, toggleName, jsonPaths) {\n    this.setState((prevState) => {\n      prevState.toggleOptions[toggleName] = newValue;\n      setQueryStringValue(toggleName, newValue);\n\n      const extraColumns = _.clone(prevState.extraColumns);\n      _.forEach(jsonPaths, (path) => {\n        if (newValue) {\n          extraColumns.push(path);\n        } else {\n          _.pull(extraColumns, path);\n        }\n      });\n      prevState.extraColumns = _.uniq(extraColumns);\n\n      return prevState;\n    });\n  }\n\n  /*\n   * Updates react state associated with the slider and calls into\n   * the non-react map code to do the same.\n   */\n  onSliderChange(timeRange) {\n    this.setTimeRange(timeRange.minTime, timeRange.maxTime);\n  }\n\n  /*\n   * Callback to updated selected log row\n   */\n  onSelectionChange(selectedRow) {\n    this.setFeaturedObject(selectedRow);\n  }\n\n  /*\n   * Set the featured object\n   */\n  setFeaturedObject(featuredObject) {\n    this.setState({ featuredObject: featuredObject });\n  }\n\n  /*\n   * exposes editing of the timeRange state\n   */\n  setTimeRange(minTime, maxTime) {\n    setQueryStringValue(\"minTime\", minTime);\n    setQueryStringValue(\"maxTime\", maxTime);\n    this.setState({\n      timeRange: {\n        minTime: minTime,\n        maxTime: maxTime,\n      },\n    });\n  }\n\n  /*\n   * Callback to handle clicks on properties in the json viewer.\n   * Adds/removes row from the log viewer based on which property\n   * in the json object was clicked on\n   */\n  onDataframePropClick(select) {\n    this.setState((prevState) => {\n      const jsonPath = _.join(select.namespace, \".\") + \".\" + select.name;\n      let newColumns;\n      if (_.find(prevState.extraColumns, (x) => x === jsonPath)) {\n        newColumns = _.without(prevState.extraColumns, jsonPath);\n      } else {\n        newColumns = [...prevState.extraColumns, jsonPath];\n      }\n      return {\n        extraColumns: newColumns,\n      };\n    });\n  }\n\n  toggleClickHandler(id) {\n    const toggle = _.find(this.toggles, { id });\n    const newValue = !this.state.toggleOptions[id];\n    this.updateToggleState(newValue, id, toggle.columns);\n  }\n\n  render() {\n    return (\n      <div>\n        <Map\n          logData={this.props.logData}\n          rangeStart={this.state.timeRange.minTime}\n          rangeEnd={this.state.timeRange.maxTime}\n          selectedRow={this.state.featuredObject}\n          toggles={this.toggles}\n          toggleOptions={this.state.toggleOptions}\n          setFeaturedObject={this.setFeaturedObject}\n          setTimeRange={this.setTimeRange}\n        />\n        <TimeSlider\n          logData={this.props.logData}\n          curMin={this.state.timeRange.minTime}\n          curMax={this.state.timeRange.maxTime}\n          onSliderChange={this.onSliderChangeDebounced}\n        />\n        <ToggleBar\n          toggles={this.toggles}\n          toggleState={this.state.toggleOptions}\n          clickHandler={(id) => this.toggleClickHandler(id)}\n        />\n        <div style={{ width: \"100%\", marginTop: \"20px\" }}>\n          <div\n            style={{\n              width: \"65%\",\n              overflowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n              float: \"left\",\n            }}\n          >\n            <LogTable\n              logData={this.props.logData}\n              style={{ width: \"100%\" }}\n              timeRange={this.state.timeRange}\n              extraColumns={this.state.extraColumns}\n              onSelectionChange={(featuredObject) =>\n                this.onSelectionChange(featuredObject)\n              }\n            />\n          </div>\n          <div\n            style={{\n              marginLeft: \"65%\",\n              overFlowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n            }}\n          >\n            <Dataframe\n              featuredObject={this.state.featuredObject}\n              onClick={(select) => this.onDataframePropClick(select)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { App as default };\n","/*\n * App.js\n *\n * Basic react app container.  Handles state for the app and\n * propagation for state changes into the non-react map\n */\nimport React from \"react\";\n\nclass ServeHome extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      vehicle: \"\",\n      trip: \"\",\n    };\n\n    this.handleVehicleChange = (event) => {\n      this.setState({ vehicle: event.target.value });\n    };\n\n    this.goVehicle = () => {\n      window.location.href = `/debugger?dataFile=/vehicles/${encodeURI(\n        this.state.vehicle\n      )}`;\n    };\n\n    this.handleTripChange = (event) => {\n      this.setState({ trip: event.target.value });\n    };\n\n    this.goTrip = () => {\n      window.location.href = `/debugger?dataFile=/trips/${encodeURI(\n        this.state.trip\n      )}`;\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Fleet Debugger Live Mode</h1>\n        <div>\n          <textarea\n            value={this.state.vehicle}\n            onChange={this.handleVehicleChange}\n            rows={1}\n            cols={64}\n          />\n          <button onClick={this.goVehicle}>Debug Vehicle</button>\n        </div>\n        <div>\n          <textarea\n            value={this.state.trip}\n            onChange={this.handleTripChange}\n            rows={1}\n            cols={64}\n          />\n          <button onClick={this.goTrip}>Debug Trip</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { ServeHome as default };\n","/*\n * Trip.js\n *\n * Processed log for a trip. Currently only includes very basic information\n * about the trip\n */\nimport _ from \"lodash\";\nimport Utils from \"./Utils\";\n\nclass Trip {\n  constructor(tripIdx, tripName, firstUpdate) {\n    this.tripIdx = tripIdx;\n    this.tripName = tripName;\n    this.updateRequests = 1;\n    this.pathCoords = [];\n    this.tripDuration = 0;\n    this.creationTime = \"Unknown\";\n    this.firstUpdate = firstUpdate;\n    this.lastUpdate = \"Unknown\";\n  }\n\n  getTraveledDistance() {\n    return window.google.maps.geometry.spherical.computeLength(this.pathCoords);\n  }\n\n  /*\n   * Returns data about trip to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      updateRequests: this.updateRequests,\n      tripName: this.tripName,\n      duration: Utils.formatDuration(this.tripDuration),\n      creationTime: this.creationTime,\n      traveledDistanceKilometers: this.getTraveledDistance() / 1000,\n      traveledDistanceMiles: this.getTraveledDistance() / 1609,\n      firstUpdate: this.firstUpdate,\n      lastUpdate: this.lastUpdate,\n    };\n  }\n\n  getPathCoords(minDate, maxDate) {\n    if (!(minDate && maxDate)) {\n      return this.pathCoords;\n    }\n    return _(this.pathCoords)\n      .filter((le) => {\n        return le.date >= minDate && le.date <= maxDate;\n      })\n      .value();\n  }\n\n  // append full raw log? would make downstream processing easier\n  // or synthesize pathCoords on the fly?\n  appendCoords(lastLocation, timestamp) {\n    this.pathCoords.push({\n      lat: lastLocation.rawlocation.latitude,\n      lng: lastLocation.rawlocation.longitude,\n      trip_id: this.tripName,\n      date: new Date(timestamp),\n    });\n  }\n}\nexport { Trip as default };\n","/*\n * stats helpers\n */\nclass Stats {\n  static median(dataSet) {\n    if (dataSet.length === 1) return dataSet[0];\n    const sorted = [...dataSet].sort();\n    const ceil = Math.ceil(sorted.length / 2);\n    const floor = Math.floor(sorted.length / 2);\n    if (ceil === floor) return sorted[floor];\n    return (sorted[ceil] + sorted[floor]) / 2;\n  }\n}\nexport { Stats as default };\n","/*\n * HighVelocityJump.js\n *\n * Representation of a HighVelocityJump\n */\nimport _ from \"lodash\";\nconst velocityOutlier = 68; // true velocities higher than this unlikely (in Meters/sec aprrox 150 MPH)\nimport Stats from \"./Stats\";\nlet computedOutlier = 0;\n\nclass HighVelocityJump {\n  constructor(jumpIdx, prevEntry, curEntry) {\n    const prevLoc = prevEntry.lastlocation;\n    const curLoc = curEntry.lastlocation;\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawlocation.latitude,\n      lng: prevLoc.rawlocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawlocation.latitude,\n      lng: curLoc.rawlocation.longitude,\n    });\n    const distanceTraveled =\n      window.google.maps.geometry.spherical.computeDistanceBetween(\n        startLoc,\n        endLoc\n      );\n    const timeSpentMS = curEntry.date - prevEntry.date;\n    const velocity = distanceTraveled / (timeSpentMS / 1000.0);\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.timeSpentMS = timeSpentMS;\n    this.distanceTraveled = distanceTraveled;\n    this.velocity = velocity;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.jumpIdx = jumpIdx;\n  }\n\n  /*\n   * Returns data about the jump to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      timeSpentMS: this.timeSpentMS,\n      distanceTraveled: this.distanceTraveled,\n      velocity: this.velocity,\n      velocityMPH: this.velocity * 2.237,\n      startLoc: this.startLoc.toString(),\n      startDate: this.prevEntry.date,\n      endDate: this.entry.date,\n      endLoc: this.endLoc.toString(),\n      jumpIdx: this.jumpIdx,\n      date: this.entry.date,\n      computedOutlierVelocity: computedOutlier,\n    };\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonpayload = {\n      \"@type\": \"Jump\",\n    };\n    featureData.lastlocation = {\n      speed: this.velocity,\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters jumps down to instances where the vehicle was\n   * travelling at an unrealistic speed (either\n   * greater that 150 MPH, or 100x median velocity).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantJumps(jumps) {\n    if (!jumps) {\n      return [];\n    }\n    const velocities = _.map(jumps, \"velocity\");\n    const avgVelocity = _.mean(velocities);\n    const medianVelocity = Stats.median(velocities);\n    const minVelocity = _.min(velocities);\n    const maxVelocity = _.max(velocities);\n    console.log(\"avgVelocity\", avgVelocity);\n    console.log(\"medianVelocity\", medianVelocity);\n    console.log(\"minVelocity\", minVelocity);\n    console.log(\"maxVelocity\", maxVelocity);\n    computedOutlier = _.min([velocityOutlier, medianVelocity * 100]);\n    return _(jumps)\n      .filter((e) => e.velocity >= computedOutlier)\n      .sortBy(\"velocity\")\n      .value();\n  }\n}\nexport { HighVelocityJump as default };\n","/*\n * MissingUpdate.js\n *\n * Representation of a missing update\n */\nimport _ from \"lodash\";\nconst updateOutlier = 60000; // 60 seconds\nimport Stats from \"./Stats\";\nimport Utils from \"./Utils\";\nlet computedOutlier = 0;\n\nclass MissingUpdate {\n  constructor(idx, prevEntry, curEntry) {\n    const interval = curEntry.date - prevEntry.date;\n    const curLoc = curEntry.lastlocation;\n    const prevLoc = prevEntry.lastlocation;\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawlocation.latitude,\n      lng: prevLoc.rawlocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawlocation.latitude,\n      lng: curLoc.rawlocation.longitude,\n    });\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.interval = interval;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.idx = idx;\n    this.startVehicleState = _.get(curEntry, \"jsonpayload.response.state\");\n    this.endVehicleState = _.get(prevEntry, \"jsonpayload.response.state\");\n    this.duration = Utils.formatDuration(this.interval);\n  }\n\n  /*\n   * Returns data about the update to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      duration: this.duration,\n      interval: this.interval,\n      startDate: this.startDate,\n      startLoc: this.startLoc.toString(),\n      endDate: this.endDate,\n      endLoc: this.endLoc.toString(),\n      startVehicleState: this.startVehicleState,\n      endVehicleState: this.endVehicleState,\n      computedOutlier: Utils.formatDuration(computedOutlier),\n    };\n  }\n\n  /*\n   * format a vehicle state transitino into something a\n   * human can easily read.\n   */\n  getStateTransition() {\n    if (!(this.startVehicleState && this.endVehicleState)) {\n      // LMFS doesn't really have vehicle states -- what's interesing here?\n      return \"\";\n    }\n    const start = this.startVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    const end = this.endVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    return start + \">\" + end;\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.date = this.startDate;\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonpayload = {\n      \"@type\": \"Missing Updates\",\n      temporal_gap: featureData.duration,\n      response: {\n        state: this.getStateTransition(),\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters updates down to instances where now updates\n   * were received from the vehicle for either 60 seconds\n   * or 10x the median observed update (our default\n   * update is every 5 seconds).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantMissingUpdates(updates) {\n    if (!updates) {\n      return [];\n    }\n    const intervals = _.map(updates, \"interval\");\n    const avgInterval = _.mean(intervals);\n    const medianInterval = Stats.median(intervals);\n    const minInterval = _.min(intervals);\n    const maxInterval = _.max(intervals);\n    console.log(\"avgInterval\", avgInterval);\n    console.log(\"medianInterval\", medianInterval);\n    console.log(\"minInterval\", minInterval);\n    console.log(\"maxInterval\", maxInterval);\n    console.log(\"updateOutlier\", updateOutlier);\n    computedOutlier = _.min([medianInterval * 10, updateOutlier]);\n    console.log(\"computedOutlier\", computedOutlier);\n    return _(updates)\n      .filter((e) => e.interval >= computedOutlier)\n      .sortBy(\"interval\")\n      .value();\n  }\n}\nexport { MissingUpdate as default };\n","/*\n * TripLogs.js\n *\n * Processes raw logs into 'trip segments'.  A trip segment might\n * be an individual trip, a contiguous non-trip region, or the route\n * between two LMFS stops.\n */\nimport _ from \"lodash\";\nimport Trip from \"./Trip\";\nimport HighVelocityJump from \"./HighVelocityJump\";\nimport MissingUpdate from \"./MissingUpdate\";\n\nconst maxDistanceForDwell = 20; // meters\nconst requiredUpdatesForDwell = 12; // aka 2 minute assuming update vehicle request at 10 seconds\n\n/* Logs from bigquery will be all lower case, so standardize on that\n */\nfunction toLowerKeys(input) {\n  if (typeof input !== \"object\") {\n    return input;\n  }\n  if (Array.isArray(input)) {\n    return input.map(toLowerKeys);\n  }\n  return Object.keys(input).reduce((newObj, key) => {\n    let val = input[key];\n    let newVal =\n      typeof val === \"object\" && val !== null ? toLowerKeys(val) : val;\n    newObj[key.toLowerCase()] = newVal;\n    return newObj;\n  }, {});\n}\n\nclass TripLogs {\n  constructor(rawLogs, solutionType) {\n    this.solutionType = solutionType;\n    if (this.solutionType === \"LMFS\") {\n      this.updateVehicleSuffix = \"update_delivery_vehicle\";\n      this.vehiclePath = \"jsonpayload.request.deliveryvehicle\";\n      this.navStatusPropName = \"navigationstatus\";\n    } else {\n      this.updateVehicleSuffix = \"update_vehicle\";\n      this.vehicleName = \"vehicle\";\n      this.vehiclePath = \"jsonpayload.request.vehicle\";\n      this.navStatusPropName = \"navstatus\";\n    }\n    this.lastLocationPath = this.vehiclePath + \".lastlocation\";\n    this.trip_ids = [];\n    this.trips = [];\n    this.tripStatusChanges = [];\n    this.rawLogs = _.reverse(rawLogs.map(toLowerKeys));\n    this.velocityJumps = [];\n    this.missingUpdates = [];\n    this.dwellLocations = [];\n    this.etaDeltas = [];\n\n    //  annotate with Dates & timestapms\n    _.map(this.rawLogs, (le, idx) => {\n      le.date = new Date(le.timestamp);\n      le.formattedDate = le.date.toISOString();\n      le.timestampMS = le.date.getTime();\n      le.idx = idx;\n      // \"synthetic\" entries that hides some of the differences\n      // between lmfs & odrd log entries\n      le.lastlocation = _.get(le, this.lastLocationPath);\n\n      // utilized for calculations of serve/client time deltas (where the\n      // server time isn't populated in the request).\n      le.lastlocationResponse = _.get(le, \"jsonpayload.response.lastlocation\");\n\n      // use the response because nav status is typically only\n      // in the request when it changes ... and visualizations\n      // make more sense when the nav status can be shown along the route\n      le.navStatus = _.get(\n        le,\n        \"jsonpayload.response.\" + this.navStatusPropName\n      );\n    });\n\n    if (this.rawLogs.length > 0) {\n      this.minDate = this.rawLogs[0].date;\n      this.maxDate = _.last(this.rawLogs).date;\n    } else {\n      this.minDate = new Date(0);\n      this.maxDate = new Date();\n    }\n    this.processTripSegments();\n  }\n\n  getRawLogs_(minDate, maxDate) {\n    minDate = minDate || this.minDate;\n    maxDate = maxDate || this.maxDate;\n    return _(this.rawLogs).filter(\n      (le) => le.date >= minDate && le.date <= maxDate\n    );\n  }\n\n  getLogs_(minDate, maxDate) {\n    return this.getRawLogs_(minDate, maxDate)\n      .concat(this.velocityJumps.map((j) => j.getLogViewerEntry()))\n      .concat(this.missingUpdates.map((u) => u.getLogViewerEntry()))\n      .filter((le) => le.date >= minDate && le.date <= maxDate)\n      .sortBy(\"timestampMS\");\n  }\n\n  getTripStatusChanges() {\n    return this.tripStatusChanges;\n  }\n\n  getTripStatusAtDate(date) {\n    const idx = _.sortedIndexBy(this.tripStatusChanges, { date }, \"date\");\n    if (idx >= 1) {\n      return this.tripStatusChanges[idx - 1].newStatus;\n    }\n  }\n\n  getTripIDs() {\n    // TODO: do time filtering heree\n    return this.trip_ids;\n  }\n\n  getTrips() {\n    // TODO: do time filtering heree\n    return this.trips;\n  }\n\n  /*\n   * Vehicles should be updating positions every 5 seconds\n   * (configurable?).  Compute places where updates are missing.\n   * aka \"Temporal jumps\".  This will be places where the\n   * app crashed, the user went off line, lost cell signal, etc.\n   */\n  getMissingUpdates(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawlocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new MissingUpdate(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.missingUpdates = MissingUpdate.getSignificantMissingUpdates(entries);\n    return this.missingUpdates;\n  }\n\n  /*\n   * Compute change in ETA to first waypoint across all location\n   * updates.\n   */\n  getETADeltas(minDate, maxDate) {\n    let prevEntry;\n    this.etaDeltas = this.getRawLogs_(minDate, maxDate)\n      .filter(\n        (le) =>\n          _.get(le, this.vehiclePath + \".etatofirstwaypoint\") &&\n          _.get(le, this.lastLocationPath + \".rawlocation\")\n      )\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          const curLoc = _.get(curEntry, this.lastLocationPath);\n\n          ret = {\n            deltaInSeconds: (curEntry.date - prevEntry.date) / 1000,\n            coords: new google.maps.LatLng({\n              lat: curLoc.rawlocation.latitude,\n              lng: curLoc.rawlocation.longitude,\n            }),\n          };\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    return this.etaDeltas;\n  }\n\n  /*\n   * Computes & returns jumps where the vehicle moved\n   * at an unrealistic velocity.\n   */\n  getHighVelocityJumps(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawlocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new HighVelocityJump(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.velocityJumps = HighVelocityJump.getSignificantJumps(entries);\n    return this.velocityJumps;\n  }\n\n  /*\n   * Rudimentary dwell location compution.  A lot of issues:\n   *    - Uses size of circle to represent dwell times ... which is confusing\n   *      w.r.t which points make up this cluster. (ie overlapping circles when\n   *      dwell locations are close by).  Should those dwell locations merged?\n   *    - Doesn't compute an actual dwell time, instead assumes UpdateVehicle requests\n   *      are 10 seconds apart\n   *    - A cluster should be within maxDistanceForDwell as well as maxTime in order to be considered\n   *      (right now clusters can be created at a location where multiple trips over days cross)\n   *    - dwell times are fuzzy. Sliders for the time & distance components might be interesting\n   *    - Doesn't respect min/max time filters from the time slider\n   *    - computation of dwell times is slow -- should cache results when turning on & off to avoid\n   *      unnecessary precomputation\n   *    - dwellLocations could be sarted by time to improve cluster lookup\n   *\n   *  See https://stackoverflow.com/questions/36928654/leader-clustering-algorithm-explanation for a\n   *  description of the very simplistic algo used here.\n   */\n  getDwellLocations(minDate, maxDate) {\n    const dwellLocations = [];\n    _.forEach(this.rawLogs, (le) => {\n      const lastLocation = le.lastlocation;\n      if (\n        !lastLocation ||\n        !lastLocation.rawlocation ||\n        le.date < minDate ||\n        le.date > maxDate\n      ) {\n        return;\n      }\n      const coord = {\n        lat: lastLocation.rawlocation.latitude,\n        lng: lastLocation.rawlocation.longitude,\n      };\n      const cluster = _.find(\n        dwellLocations,\n        (dl) =>\n          window.google.maps.geometry.spherical.computeDistanceBetween(\n            dl.leaderCoords,\n            new google.maps.LatLng(coord)\n          ) <= maxDistanceForDwell\n      );\n      if (cluster) {\n        cluster.updates++;\n        cluster.endDate = le.date;\n      } else {\n        dwellLocations.push({\n          leaderCoords: new window.google.maps.LatLng(coord),\n          updates: 1,\n          startDate: le.date,\n        });\n      }\n    });\n\n    this.dwellLocations = _.filter(\n      dwellLocations,\n      (dl) => dl.updates >= requiredUpdatesForDwell\n    );\n\n    return this.dwellLocations;\n  }\n\n  getSegmentID(logEntry) {\n    if (this.solutionType === \"LMFS\") {\n      const stopsLeft = _.get(\n        logEntry,\n        \"jsonpayload.response.remainingvehiclejourneysegments\"\n      );\n      return stopsLeft && \"Stops Left \" + stopsLeft.length;\n    } else {\n      return _.get(logEntry, \"labels.trip_id\");\n    }\n  }\n\n  processTripSegments() {\n    let curTripId = \"this is not a segment\";\n    let curTripData = undefined;\n    let tripIdx = 0;\n    let nonTripIdx = 0;\n    let lastTripStatus = \"no status\";\n    // assumes logs are already sorted\n    // also assumes out-of-order updates can't happen.  Unclear\n    // if this is a good assumption, but it might be worth it to call out\n    // places where it happens (since that might actually be a client bug).\n\n    _.forEach(this.rawLogs, (le) => {\n      if (le.logname.match(this.updateVehicleSuffix)) {\n        const newTripId = this.getSegmentID(le);\n        if (newTripId !== curTripId) {\n          curTripId = newTripId;\n          const tripName = newTripId\n            ? newTripId\n            : \"non-trip-segment-\" + nonTripIdx;\n          curTripData = new Trip(tripIdx, tripName, new Date(le.timestamp));\n          this.trips.push(curTripData);\n          this.trip_ids.push(curTripData.tripName);\n\n          tripIdx++;\n          if (newTripId === undefined) {\n            nonTripIdx++;\n          }\n        } else {\n          curTripData.lastUpdate = new Date(le.timestamp);\n          curTripData.tripDuration =\n            curTripData.lastUpdate - curTripData.firstUpdate;\n          curTripData.updateRequests++;\n        }\n        const lastLocation = _.get(le, this.lastLocationPath);\n        if (lastLocation && lastLocation.rawlocation) {\n          curTripData.appendCoords(lastLocation, le.timestamp);\n        }\n      }\n      const tripStatus = _.get(le, \"jsonpayload.response.status\");\n      // if the logs had a trip status, and it changeed update\n      if (tripStatus && tripStatus !== lastTripStatus) {\n        this.tripStatusChanges.push({\n          newStatus: tripStatus,\n          date: new Date(le.timestamp),\n        });\n        lastTripStatus = tripStatus;\n      }\n    });\n  }\n}\n\nexport { TripLogs as default };\n","/*\n * vehicleData.js\n *\n * Load raw log data for easier consumption by other components.\n */\nimport TripLogs from \"./TripLogs\";\nimport TaskLogs from \"./TaskLogs\";\nlet jwt;\nlet projectId;\nlet apikey;\nlet mapId;\nlet solutionType;\nlet tripLogs;\nlet taskLogs;\nimport { getQueryStringValue } from \"./queryString\";\n\n/**\n * This function must be called (and awaited on) to load the raw data before\n * any of the other exported fields are accessed.\n */\nasync function loadData() {\n  const dataFileName = getQueryStringValue(\"dataFile\") || \"./data.json\";\n  const response = await fetch(dataFileName);\n  const parsedData = await response.json();\n  jwt = parsedData.jwt;\n  projectId = parsedData.projectId;\n  apikey = parsedData.APIKEY;\n  mapId = parsedData.mapId;\n  solutionType = parsedData.solutionType || \"ODRD\";\n  tripLogs = new TripLogs(parsedData.rawLogs, solutionType);\n  if (solutionType === \"LMFS\") {\n    // refactor: some initial log processing is done by TripLogs\n    taskLogs = new TaskLogs(tripLogs);\n  }\n}\n\nexport {\n  loadData,\n  tripLogs,\n  taskLogs,\n  apikey,\n  mapId,\n  jwt,\n  projectId,\n  solutionType,\n};\n","/*\n * Task.js\n *\n * Processed log for a task.  Handles computing the state of\n * a task at a specified time.\n */\nimport _ from \"lodash\";\n\nclass Task {\n  constructor(date, taskIdx, taskReq, taskResp) {\n    this.taskIdx = taskIdx;\n    this.taskId = taskReq.taskid;\n    this.updates = [];\n    this.firstUpdate = date;\n    this.addUpdate(date, taskReq, taskReq, taskResp);\n  }\n\n  /**\n   * Returns the status of the task at the specified date.  Note that\n   * many task changes are actually done as side-effects of vehicle changes\n   * and thus the debugger only has visibily into a task change if there\n   * is an update_task call made.\n   */\n  getTaskInfo(maxDate) {\n    const taskInfo = {\n      taskid: this.taskId,\n    };\n    const lastUpdate = _(this.updates)\n      .filter((update) => update.date <= maxDate)\n      .last();\n\n    if (lastUpdate) {\n      // The create vs update task input and output protos are annoyingly\n      // different.  The following code attemps to handle both.\n      taskInfo.type = lastUpdate.taskResp.type || lastUpdate.taskReq.task.type;\n      taskInfo.plannedlocation =\n        lastUpdate.taskResp.plannedlocation ||\n        lastUpdate.taskReq.task.plannedlocation;\n      taskInfo.taskoutcome = lastUpdate.taskResp.taskoutcome;\n      taskInfo.state = lastUpdate.taskResp.state;\n      taskInfo.taskoutcomelocationsource =\n        lastUpdate.taskResp.taskoutcomelocationsource;\n      taskInfo.taskoutcomelocation = lastUpdate.taskResp.taskoutcomelocation;\n      taskInfo.taskoutcometime = lastUpdate.taskResp.taskoutcometime;\n      taskInfo.trackingid =\n        lastUpdate.taskResp.trackingid || lastUpdate.taskReq.task.trackingid;\n      if (taskInfo.taskoutcomelocationsource) {\n        taskInfo.plannedVsActualDeltaMeters =\n          window.google.maps.geometry.spherical.computeDistanceBetween(\n            {\n              lat: taskInfo.plannedlocation.point.latitude,\n              lng: taskInfo.plannedlocation.point.longitude,\n            },\n            {\n              lat: taskInfo.taskoutcomelocation.point.latitude,\n              lng: taskInfo.taskoutcomelocation.point.longitude,\n            }\n          );\n      }\n    }\n    return taskInfo;\n  }\n\n  addUpdate(date, taskReq, taskResp) {\n    this.lastUpdate = date;\n    this.updates.push({\n      date,\n      taskReq,\n      taskResp,\n    });\n  }\n}\nexport { Task as default };\n","/*\n * TaskLogs.js\n *\n * Processes raw logs into task oriented logs where a single entry\n * contains all the information about a task.\n */\nimport _ from \"lodash\";\nimport Task from \"./Task\";\nclass TaskLogs {\n  constructor(tripLogs) {\n    this.tasks = {};\n    this.processTasks(tripLogs.getRawLogs_());\n    this.minDate = tripLogs.minDate;\n    this.maxDate = tripLogs.maxDate;\n  }\n\n  processTasks(logs) {\n    _(logs)\n      .filter(\n        // TODO #133: response can be empty on errors -- we should highlight those rows!!\n        (le) =>\n          (le.logname.match(\"create_task\") ||\n            le.logname.match(\"update_task\")) &&\n          le.jsonpayload.response\n      )\n      .forEach((le, taskIdx) => {\n        const taskReq = le.jsonpayload.request;\n        const taskResp = le.jsonpayload.response;\n        let task = this.tasks[taskReq.taskid];\n        if (!task) {\n          task = this.tasks[taskReq.taskid] = new Task(\n            le.date,\n            taskIdx,\n            taskReq,\n            taskResp\n          );\n        } else {\n          task.addUpdate(le.date, taskReq, taskResp);\n        }\n      });\n  }\n\n  /*\n   * Tasks are always shown -- no matter the state of the timeslider.\n   *\n   * The timeslider is used purely to control what task state/outcome\n   * is displayed.\n   */\n  getTasks(maxDate) {\n    maxDate = maxDate || this.maxDate;\n    return _(this.tasks)\n      .values()\n      .map((task) => task.getTaskInfo(maxDate))\n      .compact();\n  }\n}\n\nexport { TaskLogs as default };\n","/*\n * index.js\n */\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport ServeHome from \"./ServeHome\";\nimport { getQueryStringValue } from \"./queryString\";\nimport {\n  tripLogs,\n  taskLogs,\n  loadData,\n  apikey,\n  mapId,\n  jwt,\n  projectId,\n  solutionType,\n} from \"./vehicleData\";\n\nconst params = {\n  serveMode: getQueryStringValue(\"serve\"),\n};\n\nif (params.serveMode) {\n  ReactDOM.render(\n    <div>\n      <ServeHome />\n    </div>,\n    document.getElementById(\"root\")\n  );\n} else {\n  loadData(params).then(() => {\n    const logData = {\n      tripLogs,\n      taskLogs,\n      apikey,\n      mapId,\n      jwt,\n      projectId,\n      solutionType,\n    };\n    ReactDOM.render(\n      <div>\n        <App logData={logData} />\n      </div>,\n      document.getElementById(\"root\")\n    );\n  });\n}\n"],"sourceRoot":""}