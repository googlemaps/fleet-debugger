{"version":3,"sources":["Map.js","Dataframe.js","TimeSlider.js","LogTable.js","ToggleBar.js","vehicleData.js","App.js","Utils.js","Trip.js","Stats.js","HighVelocityJump.js","MissingUpdate.js","TripLogs.js","index.js"],"names":["minDate","maxDate","map","apikey","trafficLayer","panorama","jwt","projectId","locationProvider","solutionType","tripLogs","setFeaturedObject","setTimeRange","allPaths","allMarkers","dataMakers","bubbleMap","toggleHandlers","render","status","Status","LOADING","FAILURE","addTripPolys","_","forEach","p","setMap","m","lastVehicleCoords","trips","getTrips","vehicleBounds","window","google","maps","LatLngBounds","trip","bounds","tripCoords","getPathCoords","length","last","path","Polyline","geodesic","strokeColor","getColor","tripIdx","strokeOpacity","strokeWeight","event","addListener","setOptions","fd","getFeaturedData","firstUpdate","getTime","lastUpdate","getPath","e","extend","push","lastVehicleLocMark","Marker","position","icon","url","scaledSize","Size","title","MyMapComponent","ref","useRef","useEffect","element","current","journeySharing","FleetEngineTripLocationProvider","authTokenFetcher","options","console","log","token","JourneySharingMapView","fitBounds","id","style","height","colors","Map","props","logData","urlParams","URLSearchParams","location","search","get","apiKey","version","libraries","onSliderChangeMap","debounce","rangeStart","rangeEnd","Date","handler","name","GenerateBubbles","bubbleName","cb","showBubble","bubble","getLogs_","le","rawLocation","lastLocation","undefined","LatLng","lat","latitude","lng","longitude","compact","value","rawLocationLatLng","color","locSensor","accuracy","rawLocationAccuracy","circ","Circle","fillColor","fillOpacity","center","radius","logEntry","clientTimeStr","serverTimeStr","clientDate","serverDate","timeDeltaSeconds","Math","abs","heading","headingLine","icons","SymbolPath","FORWARD_CLOSED_ARROW","offset","geometry","spherical","computeOffset","StreetViewPanorama","document","getElementById","pov","pitch","addressControlOptions","ControlPosition","BOTTOM_CENTER","linksControl","panControl","enableCloseButton","speed","enabled","TrafficLayer","dwellLocations","getDwellLocations","dl","leaderCoords","updates","jumps","getHighVelocityJumps","jump","getStrokeWeight","velocity","startLoc","endLoc","jumpIdx","startDate","endDate","flatten","missingUpdates","getMissingUpdates","update","interval","offsetHeading","computeHeading","points","scale","CIRCLE","tripId","getTripIDs","Dataframe","src","featuredObject","onSelect","onClick","Range","createSliderWithTooltip","Slider","width","TimeSlider","marks","getTripStatusChanges","change","date","minVal","maxVal","curMin","max","curMax","min","step","onChange","onSliderChange","minTime","maxTime","defaultValue","tipFormatter","d","tripStatus","getTripStatusAtDate","Styles","styled","div","Table","columns","data","onSelectionChange","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","row","getRowProps","original","cells","cell","getCellProps","TrimCell","trim","replace","LogTable","timeRange","React","useMemo","stdColumns","Header","accessor","Cell","extraColumns","dotPath","elems","split","Button","button","ButtonToggle","active","docLinks","ButtonGroup","ToggleBar","showGPSBubbles","onClickGPSBubbles","href","target","rel","showHeading","onClickHeading","showSpeed","onClickSpeed","showDwellLocations","onClickDwellLocations","showHighVelocityJumps","onClickHighVelocityJumps","showMissingUpdates","onClickMissingUpdates","showClientServerTimeDeltas","onClickClientServerTimeDeltas","showTraffic","onClickTraffic","showLiveJS","onClickLiveJS","App","nowDate","state","setFullYear","getFullYear","msg","toggleOptions","onSliderChangeDebounced","fo","toggleName","jsonPaths","this","setState","prevState","newValue","updateMapToggles","clone","pull","updateColumns","selectedRow","svgMarker","rotation","anchor","Point","locationForLog","addMarkersToMapForData","select","jsonPath","join","namespace","find","x","without","marginTop","overflowX","overFlowY","float","marginLeft","overFlowX","onDataframePropClick","Component","Utils","duration","sec_num","hours","floor","minutes","seconds","timeStr","Trip","tripName","updateRequests","pathCoords","tripDuration","creationTime","computeLength","formatDuration","traveledDistanceKilometers","getTraveledDistance","traveledDistanceMiles","filter","timestamp","trip_id","Stats","dataSet","sorted","sort","ceil","computedOutlier","HighVelocityJump","prevEntry","curEntry","prevLoc","curLoc","distanceTraveled","computeDistanceBetween","timeSpentMS","entry","velocityMPH","toString","computedOutlierVelocity","featureData","timestampMS","formattedDate","toISOString","jsonPayload","request","vehicle","velocities","avgVelocity","mean","medianVelocity","median","minVelocity","maxVelocity","sortBy","MissingUpdate","idx","startVehicleState","endVehicleState","temporal_gap","response","getStateTransition","intervals","avgInternal","medianInternal","minInternal","maxInternal","TripLogs","rawLogs","updateVehicleSuffix","lastLocationPath","vehicleName","trip_ids","tripStatusChanges","reverse","processTripSegments","velocityJumps","getRawLogs_","concat","j","getLogViewerEntry","u","sortedIndexBy","newStatus","entries","ret","getSignificantMissingUpdates","getSignificantJumps","coord","cluster","stopsLeft","curTripId","curTripData","nonTripIdx","lastTripStatus","logName","match","newTripId","getSegmentID","appendCoords","a","fetch","json","parsedData","APIKEY","loadData","then","ReactDOM"],"mappings":"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","file":"static/js/main.b6fc3059.chunk.js","sourcesContent":["/*\n * Map.js\n *\n * Uses the react-wrapper to make using google maps js sdk\n * easier in react.  Beyond basic loading doesn't pretend to\n * act like a normal react component.\n */\nimport { Wrapper, Status } from \"@googlemaps/react-wrapper\";\nimport { useEffect, useRef } from \"react\";\nimport _ from \"lodash\";\n\nlet minDate;\nlet maxDate;\nlet allPaths = [];\nlet allMarkers = [];\nlet map;\nlet apikey;\nlet dataMakers = [];\nlet trafficLayer;\nconst bubbleMap = {};\nconst toggleHandlers = {};\nlet panorama;\nlet jwt;\nlet projectId;\nlet locationProvider;\nlet solutionType;\nlet tripLogs;\nlet setFeaturedObject;\nlet setTimeRange;\n\nconst render = (status) => {\n  if (status === Status.LOADING) return <h3>{status} ..</h3>;\n  if (status === Status.FAILURE) return <h3>{status} ...</h3>;\n  return null;\n};\n\nfunction addTripPolys(map) {\n  _.forEach(allPaths, (p) => p.setMap(null));\n  allPaths = [];\n  _.forEach(allMarkers, (m) => m.setMap(null));\n  allMarkers = [];\n\n  const trips = tripLogs.getTrips();\n  const vehicleBounds = new window.google.maps.LatLngBounds();\n  let lastVehicleCoords;\n  _.forEach(trips, (trip) => {\n    const tripCoords = trip.getPathCoords(minDate, maxDate);\n    if (tripCoords.length > 0) {\n      lastVehicleCoords = _.last(tripCoords);\n      const path = new window.google.maps.Polyline({\n        path: tripCoords,\n        geodesic: true,\n        strokeColor: getColor(trip.tripIdx),\n        strokeOpacity: 0.5,\n        strokeWeight: 6,\n      });\n      google.maps.event.addListener(path, \"mouseover\", () => {\n        path.setOptions({\n          strokeOpacity: 1,\n          strokeWeight: 8,\n        });\n      });\n      google.maps.event.addListener(path, \"mouseout\", () => {\n        path.setOptions({\n          strokeOpacity: 0.5,\n          strokeWeight: 6,\n        });\n      });\n      google.maps.event.addListener(path, \"click\", () => {\n        const fd = trip.getFeaturedData();\n        setFeaturedObject(fd);\n        // TODO: https://github.com/googlemaps/fleet-debugger/issues/79\n        // this time range won't capture the createTrip logs\n        setTimeRange(fd.firstUpdate.getTime(), fd.lastUpdate.getTime());\n      });\n      getPolyBounds(vehicleBounds, path);\n      path.setMap(map);\n      allPaths.push(path);\n    }\n  });\n  if (lastVehicleCoords) {\n    const urlBase = \"http://maps.google.com/mapfiles/kml/shapes/\";\n    const lastVehicleLocMark = new window.google.maps.Marker({\n      position: lastVehicleCoords,\n      map: map,\n      icon: {\n        url: urlBase + (solutionType === \"LMFS\" ? \"truck.png\" : \"cabs.png\"),\n        scaledSize: new google.maps.Size(25, 25),\n      },\n      title: \"Last Location\",\n    });\n    allMarkers.push(lastVehicleLocMark);\n  }\n  return vehicleBounds;\n}\n\n/*\n * Creates the map object using a journeySharing location\n * provider.\n */\nfunction initializeMapObject(element) {\n  // In a more normal implementation authTokenFetcher\n  // would actually be making a RPC to a backend to generate\n  // the jwt.  For debugging use cases the jwt gets bundled into\n  // the extracted log data.\n  function authTokenFetcher(options) {\n    // TODO #25 - bake in actual expiration time -- and give a\n    // better error message for expired jwts\n    console.log(\"Ignoring options using prebuilt jwt\", options);\n    const authToken = {\n      token: jwt,\n    };\n    return authToken;\n  }\n\n  locationProvider =\n    new google.maps.journeySharing.FleetEngineTripLocationProvider({\n      projectId,\n      authTokenFetcher,\n    });\n  const jsMapView = new google.maps.journeySharing.JourneySharingMapView({\n    element: element,\n    locationProvider,\n  });\n  return jsMapView.map;\n}\n\nfunction MyMapComponent() {\n  const ref = useRef();\n\n  useEffect(() => {\n    map = initializeMapObject(ref.current);\n    const vehicleBounds = addTripPolys(map);\n    map.fitBounds(vehicleBounds);\n  });\n\n  return <div ref={ref} id=\"map\" style={{ height: \"500px\" }} />;\n}\n\nfunction getPolyBounds(bounds, p) {\n  p.getPath().forEach((e) => {\n    bounds.extend(e);\n  });\n  return bounds;\n}\n\n/*\n * Deterministically assign a color per trip using tripIdx\n * Colors were chosen for visibility\n */\nfunction getColor(tripIdx) {\n  const colors = [\n    \"#2d7dd2\",\n    \"#97cc04\",\n    \"#eeb902\",\n    \"#f45d01\",\n    \"#474647\",\n    \"00aa00\",\n  ];\n  return colors[tripIdx % colors.length];\n}\n\nfunction Map(props) {\n  tripLogs = props.logData.tripLogs;\n  minDate = tripLogs.minDate.getTime();\n  maxDate = tripLogs.maxDate.getTime();\n  const urlParams = new URLSearchParams(window.location.search);\n  apikey = urlParams.get(\"apikey\") || props.logData.apikey;\n  jwt = props.logData.jwt;\n  projectId = props.logData.projectId;\n  solutionType = props.logData.solutionType;\n\n  return (\n    <Wrapper\n      apiKey={apikey}\n      render={render}\n      version=\"beta\"\n      libraries={[\"geometry\", \"journeySharing\"]}\n    >\n      <MyMapComponent />\n    </Wrapper>\n  );\n}\n\n/*\n * Handler for timewindow change.  Updates global min/max date globals\n * and recomputes the paths as well as all the bubble markers to respect the\n * new date values.\n *\n * Debounced to every 100ms as a blance between performance and reactivity when\n * the slider is dragged.\n */\nconst onSliderChangeMap = _.debounce((rangeStart, rangeEnd) => {\n  minDate = new Date(rangeStart);\n  maxDate = new Date(rangeEnd);\n  addTripPolys(map);\n  _.forEach(toggleHandlers, (handler, name) => {\n    if (bubbleMap[name]) {\n      handler(true);\n    }\n  });\n}, 100);\n\nfunction addMarkersToMapForData(data) {\n  _.forEach(dataMakers, (m) => m.setMap(null));\n  dataMakers = [];\n  const svgMarker = {\n    path: \"M10.453 14.016l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM12 2.016q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z\",\n    fillColor: \"blue\",\n    fillOpacity: 0.6,\n    strokeWeight: 0,\n    rotation: 0,\n    scale: 2,\n    anchor: new google.maps.Point(15, 30),\n  };\n\n  const rawLocation = _.get(\n    data,\n    \"jsonPayload.request.vehicle.lastLocation.rawLocation\"\n  );\n  if (rawLocation) {\n    const status = _.get(data, \"jsonPayload.response.status\");\n    const state = _.get(data, \"jsonPayload.response.state\");\n    const locationForLog = new window.google.maps.Marker({\n      position: { lat: rawLocation.latitude, lng: rawLocation.longitude },\n      map: map,\n      icon: svgMarker,\n      title: \"Vehicle state \" + state + \" Trip Status \" + status,\n    });\n    dataMakers.push(locationForLog);\n  }\n  // TODO: for non-vehicle api calls could attempt to interpolate the location\n}\n\n/*\n * GenerateBubbles() -- helper function for generating map features based\n * on per-log entry data.\n *\n * Handles the gunk of iterating over log entries and clearing/setting the map\n */\nfunction GenerateBubbles(bubbleName, cb) {\n  return (showBubble) => {\n    _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n    delete bubbleMap[bubbleName];\n    if (showBubble) {\n      bubbleMap[bubbleName] = tripLogs\n        .getLogs_(minDate, maxDate)\n        .map((le) => {\n          const lastLocation = _.get(\n            le,\n            \"jsonPayload.request.vehicle.lastLocation\"\n          );\n          let rawLocation;\n          let bubble = undefined;\n          if (lastLocation && (rawLocation = lastLocation.rawLocation)) {\n            bubble = cb(\n              new google.maps.LatLng({\n                lat: rawLocation.latitude,\n                lng: rawLocation.longitude,\n              }),\n              lastLocation,\n              le\n            );\n          }\n          return bubble;\n        })\n        .compact()\n        .value();\n    }\n  };\n}\n\n/*\n * Draws circles on map with a radius equal to the\n * GPS accuracy.\n */\ntoggleHandlers[\"showGPSBubbles\"] = GenerateBubbles(\n  \"showGPSBubbles\",\n  (rawLocationLatLng, lastLocation) => {\n    let color;\n    switch (lastLocation.locSensor) {\n      case \"LOCATION_SENSOR_GPS\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_NETWORK\":\n        color = \"#FF1111\";\n        break;\n      case \"LOCATION_SENSOR_PASSIVE\":\n        color = \"#FF0000\";\n        break;\n      case \"LOCATION_SENSOR_ROAD_SNAPPED_LOCATION_PROVIDER\":\n        color = \"#00FF00\";\n        break;\n      case \"LOCATION_SENSOR_FUSED_LOCATION_PROVIDER\":\n        color = \"#11FF11\";\n        break;\n      case \"LOCATION_SENSOR_LOG_UNSPECIFIED\":\n      default:\n        color = \"#000000\";\n    }\n    const accuracy = lastLocation.rawLocationAccuracy;\n    if (accuracy) {\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: accuracy, // units is this actually meters?\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          rawLocationAccuracy: lastLocation.rawLocationAccuracy,\n          locSensor: lastLocation.locSensor,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws circles on map with a radius equal to the\n * time delta (1 meter radius = 1 second of delta)\n */\ntoggleHandlers[\"showClientServerTimeDeltas\"] = GenerateBubbles(\n  \"showClientServerTimeDeltas\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    const clientTimeStr = _.get(\n      logEntry,\n      \"jsonPayload.response.lastLocation.rawLocationTime\"\n    );\n    const serverTimeStr = _.get(\n      logEntry,\n      \"jsonPayload.response.lastLocation.serverTime\"\n    );\n    if (clientTimeStr && serverTimeStr) {\n      const clientDate = new Date(clientTimeStr);\n      const serverDate = new Date(serverTimeStr);\n      const timeDeltaSeconds =\n        Math.abs(clientDate.getTime() - serverDate.getTime()) / 1000;\n      let color;\n      if (clientDate > serverDate) {\n        color = \"#0000F0\";\n      } else {\n        color = \"#0F0000\";\n      }\n\n      let circ = new google.maps.Circle({\n        strokeColor: color,\n        strokeOpacity: 0.6,\n        strokeWeight: 2,\n        fillColor: color,\n        fillOpacity: 0.2,\n        map,\n        center: rawLocationLatLng,\n        radius: timeDeltaSeconds,\n      });\n      google.maps.event.addListener(circ, \"mouseover\", () => {\n        setFeaturedObject({\n          timeDeltaSeconds: timeDeltaSeconds,\n          serverDate: serverDate,\n          clientDate: clientDate,\n        });\n      });\n      return circ;\n    }\n  }\n);\n\n/*\n * Draws arrows on map showing the measured heading\n * of the vehicle (ie which direction vehicle was traveling\n */\ntoggleHandlers[\"showHeading\"] = GenerateBubbles(\n  \"showHeading\",\n  (rawLocationLatLng, lastLocation, logEntry) => {\n    // Note: Heading & accuracy are only on the _request_ not the\n    // response.\n    const heading = _.get(\n      logEntry,\n      \"jsonPayload.request.vehicle.lastLocation.heading\"\n    );\n    const accuracy = _.get(\n      logEntry,\n      \"jsonPayload.request.vehicle.lastLocation.bearingAccuracy\"\n    );\n\n    // Not currently using accuracy. How to show it?  Maybe opacity of the arrorw?\n    const arrowLength = 20; // meters??\n    if (!(heading && accuracy)) {\n      return;\n    }\n    const headingLine = new google.maps.Polyline({\n      strokeColor: \"#0000F0\",\n      strokeOpacity: 0.6,\n      strokeWeight: 2,\n      icons: [\n        {\n          icon: {\n            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n            strokeColor: \"#0000FF\",\n            strokeWeight: 4,\n          },\n          offset: \"100%\",\n        },\n      ],\n      map,\n      path: [\n        rawLocationLatLng,\n        google.maps.geometry.spherical.computeOffset(\n          rawLocationLatLng,\n          arrowLength,\n          heading\n        ),\n      ],\n    });\n    google.maps.event.addListener(headingLine, \"click\", () => {\n      // TODO: allow updating panorama based on forward/back\n      // stepper buttons (ie at each updatevehicle log we have a heading)\n      panorama = new google.maps.StreetViewPanorama(\n        document.getElementById(\"map\"),\n        {\n          position: rawLocationLatLng,\n          pov: { heading: heading, pitch: 10 },\n          addressControlOptions: {\n            position: google.maps.ControlPosition.BOTTOM_CENTER,\n          },\n          linksControl: false,\n          panControl: false,\n          enableCloseButton: true,\n        }\n      );\n      console.log(\"loaded panorama\", panorama);\n    });\n    return headingLine;\n  }\n);\n\n/*\n * Draws circles on the map. Color indicates vehicle speed at that\n * location.\n */\ntoggleHandlers[\"showSpeed\"] = GenerateBubbles(\n  \"showSpeed\",\n  (rawLocationLatLng, lastLocation) => {\n    const speed = lastLocation.speed;\n    if (lastLocation.speed === undefined) {\n      return;\n    }\n    const color = speed < 0 ? \"#FF0000\" : \"#00FF00\";\n    return new google.maps.Circle({\n      strokeColor: color,\n      strokeOpacity: 0.5,\n      fillColor: color,\n      fillOpacity: 0.5,\n      map,\n      center: rawLocationLatLng,\n      radius: Math.abs(speed),\n    });\n  }\n);\n\n/*\n * Enable/disables live traffic layer\n */\ntoggleHandlers[\"showTraffic\"] = function (enabled) {\n  if (!trafficLayer) {\n    trafficLayer = new google.maps.TrafficLayer();\n  }\n  if (enabled) {\n    trafficLayer.setMap(map);\n  } else {\n    trafficLayer.setMap(null);\n  }\n};\n\n/*\n * Draws circles on the map. Size indicates dwell time at that\n * location.\n */\ntoggleHandlers[\"showDwellLocations\"] = function (enabled) {\n  const bubbleName = \"showDwellLocations\";\n  const dwellLocations = tripLogs.getDwellLocations(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _.map(dwellLocations, (dl) => {\n      return new google.maps.Circle({\n        strokeColor: \"#000000\",\n        strokeOpacity: 0.25,\n        fillColor: \"#FFFF00\",\n        fillOpacity: 0.25,\n        map,\n        center: dl.leaderCoords,\n        radius: dl.updates * 3, // make dwell times more obvious\n      });\n    });\n  }\n};\n\n/*\n * Draws arrows on the map showing where a vehicle jumped\n * from one location to another at an unrealistic velocity.\n */\ntoggleHandlers[\"showHighVelocityJumps\"] = function (enabled) {\n  const bubbleName = \"showHighVelocityJumps\";\n  const jumps = tripLogs.getHighVelocityJumps(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(jumps)\n      .map((jump) => {\n        function getStrokeWeight(velocity) {\n          if (velocity <= 100) {\n            return 2;\n          } else if (velocity < 1000) {\n            return 6;\n          } else if (velocity < 2000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const path = new window.google.maps.Polyline({\n          path: [jump.startLoc, jump.endLoc],\n          geodesic: true,\n          strokeColor: getColor(jump.jumpIdx),\n          strokeOpacity: 0.8,\n          strokeWeight: getStrokeWeight(jump.velocity),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: getColor(jump.jumpIdx),\n                strokeWeight: getStrokeWeight(jump.velocity),\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(jump.getFeaturedData());\n          // show a minute +/- on each side of a jump\n          setTimeRange(\n            jump.startDate.getTime() - 60 * 1000,\n            jump.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Marks locations on the map where we did not get the expected\n * updateVehicle requests\n */\ntoggleHandlers[\"showMissingUpdates\"] = function (enabled) {\n  const bubbleName = \"showMissingUpdates\";\n  const missingUpdates = tripLogs.getMissingUpdates(minDate, maxDate);\n  _.forEach(bubbleMap[bubbleName], (bubble) => bubble.setMap(null));\n  delete bubbleMap[bubbleName];\n  if (enabled) {\n    bubbleMap[bubbleName] = _(missingUpdates)\n      .map((update) => {\n        function getStrokeWeight(interval) {\n          if (interval <= 60 * 1000) {\n            return 2;\n          } else if (interval < 60 * 10 * 1000) {\n            return 6;\n          } else if (interval < 60 * 60 * 10 * 1000) {\n            return 10;\n          } else {\n            return 14;\n          }\n        }\n        const heading = google.maps.geometry.spherical.computeHeading(\n          update.startLoc,\n          update.endLoc\n        );\n        const offsetHeading = ((heading + 360 + 90) % 360) - 180;\n        const points = [\n          update.startLoc,\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.startLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            900, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          google.maps.geometry.spherical.computeOffset(\n            update.endLoc,\n            1000, //TODO compute based on viewport?\n            offsetHeading\n          ),\n          update.endLoc,\n        ];\n        const path = new window.google.maps.Polyline({\n          path: points,\n          geodesic: true,\n          strokeColor: \"#008B8B\",\n          strokeOpacity: 0.5,\n          strokeWeight: getStrokeWeight(update.interval),\n          map: map,\n          icons: [\n            {\n              icon: {\n                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,\n                strokeColor: \"#008B8B\",\n                strokeWeight: getStrokeWeight(update.interval),\n                scale: 6,\n              },\n              offset: \"50%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"0%\",\n            },\n            {\n              icon: {\n                path: google.maps.SymbolPath.CIRCLE,\n                scale: 6,\n                strokeColor: \"#000000\",\n                strokeWeight: 1,\n                strokeOpacity: 0.5,\n              },\n              offset: \"100%\",\n            },\n          ],\n        });\n        google.maps.event.addListener(path, \"mouseover\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          path.setOptions({\n            strokeOpacity: 1,\n            strokeWeight: 1.5 * getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"mouseout\", () => {\n          path.setOptions({\n            strokeOpacity: 0.5,\n            strokeWeight: getStrokeWeight(update.interval),\n          });\n        });\n        google.maps.event.addListener(path, \"click\", () => {\n          setFeaturedObject(update.getFeaturedData());\n          // show a minute +/- on each side of a update\n          setTimeRange(\n            update.startDate.getTime() - 60 * 1000,\n            update.endDate.getTime() + 60 * 1000\n          );\n        });\n        return [path];\n      })\n      .flatten()\n      .value();\n  } else {\n    // TODO: ideally reset to timerange that was selected before enabling\n    // jump view\n    setTimeRange(tripLogs.minDate.getTime(), tripLogs.maxDate.getTime());\n  }\n};\n\n/*\n * Enable/disables live journey sharing view\n */\ntoggleHandlers[\"showLiveJS\"] = function (enabled) {\n  if (!jwt) {\n    console.log(\"Issue #25 -- no/invalid jwt\");\n    return;\n  }\n  // call into js to set the trip\n  if (enabled) {\n    locationProvider.tripId = _.last(tripLogs.getTripIDs());\n  } else {\n    locationProvider.tripId = \"\";\n  }\n};\n\nfunction updateMapToggles(toggleName, enabled) {\n  toggleHandlers[toggleName](enabled);\n}\n\n/*\n * Register handlers that allow this code to call\n * into react components.  (ie display trip data\n * in the object viewer component when a vehicle track\n * polyline  is clicked on).\n */\nfunction registerHandlers(featureObject, timeRange) {\n  setFeaturedObject = featureObject;\n  setTimeRange = timeRange;\n}\n\nexport {\n  Map as default,\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n};\n","/*\n * Dataframe.js\n *\n * JSON viewer for log entries.   Clicking on a property _value_\n * adds it to the log viewer.\n *\n * TODO: support clicking on the property name as well, or support an\n * icon or other UI element (similar to copy to clip board).\n */\nimport ReactJson from \"react-json-view\";\nfunction Dataframe(props) {\n  return <ReactJson src={props.featuredObject} onSelect={props.onClick} />;\n}\n\n// TODO: Ideas: allow selecting a field and see how it changes along the map\n// or the slider (ie view on map / view on slider)\n// or 'add slider' that instantiates a slider that has marks\n// when that value changes\nexport default Dataframe;\n","/*\n * TimeSlider.js\n *\n * Provides a time-based visualaziton of key events (vehicle status changes) as well\n * as filtering control for the log viewer & map view.\n *\n * TODO: not clear that rc-slider is actually the correct/best component for this\n * functionality\n */\nimport Slider from \"rc-slider\";\nimport \"rc-slider/assets/index.css\";\nimport _ from \"lodash\";\n\nconst { createSliderWithTooltip } = Slider;\nconst Range = createSliderWithTooltip(Slider.Range);\n\nconst style = { width: \"100%\" };\n\nfunction TimeSlider(props) {\n  const tripLogs = props.logData.tripLogs;\n  const marks = {};\n\n  // Add marks showing when trip status changed.\n  // Ideally label by trip status change ... but labels overrun & look ugly\n  _.map(tripLogs.getTripStatusChanges(), (change) => {\n    marks[change.date.getTime()] = {};\n  });\n\n  const minVal = tripLogs.minDate.getTime();\n  const maxVal = tripLogs.maxDate.getTime();\n\n  const curMin = _.max([minVal, props.curMin]);\n  const curMax = _.min([maxVal, props.curMax]);\n\n  function onChange(value) {\n    props.onSliderChange({\n      minTime: value[0],\n      maxTime: value[1],\n    });\n  }\n\n  function formatTooltip(value) {\n    const d = new Date(value);\n    const tripStatus = tripLogs.getTripStatusAtDate(new Date(value));\n    return `${d}${tripStatus}`;\n  }\n\n  return (\n    <div style={style}>\n      <Range\n        min={minVal}\n        max={maxVal}\n        marks={marks}\n        step={1}\n        onChange={onChange}\n        defaultValue={[minVal, maxVal]}\n        value={[curMin, curMax]}\n        tipFormatter={formatTooltip}\n      />\n    </div>\n  );\n}\n\nexport default TimeSlider;\n","/*\n * LogTable.js\n *\n * Handles the log viewing component.\n */\nimport { useTable } from \"react-table\";\nimport React from \"react\";\nimport styled from \"styled-components\";\nimport _ from \"lodash\";\n\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n  }\n`;\n\nfunction Table({ columns, data, onSelectionChange }) {\n  const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } =\n    useTable({\n      columns,\n      data,\n    });\n\n  return (\n    <table {...getTableProps()}>\n      <thead>\n        {headerGroups.map((headerGroup) => (\n          <tr {...headerGroup.getHeaderGroupProps()}>\n            {headerGroup.headers.map((column) => (\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\n            ))}\n          </tr>\n        ))}\n      </thead>\n      <tbody {...getTableBodyProps()}>\n        {rows.map((row) => {\n          prepareRow(row);\n          return (\n            <tr\n              {...row.getRowProps()}\n              onClick={() => onSelectionChange(row.original)}\n            >\n              {row.cells.map((cell) => {\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\n              })}\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\n/*\n * Helper method for removing common substrings in cells.  Typically\n * used for removing a prefix from ENUMs.\n */\nconst TrimCell = ({ value, trim }) => {\n  return <>{value && value.replace(trim, \"\")}</>;\n};\n\nfunction LogTable(props) {\n  const minTime = props.timeRange.minTime;\n  const maxTime = props.timeRange.maxTime;\n  const data = props.logData.tripLogs\n    .getLogs_(new Date(minTime), new Date(maxTime))\n    .value();\n\n  const columns = React.useMemo(() => {\n    const stdColumns = [\n      {\n        Header: \"Date\",\n        accessor: \"formattedDate\",\n      },\n      {\n        Header: \"SDK Version\",\n        accessor: \"jsonPayload.request.header.sdkVersion\",\n      },\n      {\n        Header: \"OS Version\",\n        accessor: \"jsonPayload.request.header.osVersion\",\n      },\n      {\n        Header: \"Method\",\n        accessor: \"jsonPayload.@type\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell\n            value={value}\n            trim=\"type.googleapis.com/maps.fleetengine.\"\n          />\n        ),\n      },\n      {\n        Header: \"Vehicle\",\n        accessor: \"labels.vehicle_id\",\n      },\n      {\n        Header: \"Trip\",\n        accessor: \"labels.trip_id\",\n      },\n      {\n        Header: \"Vehicle State\",\n        accessor: \"jsonPayload.response.state\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"VEHICLE_STATE_\" />\n        ),\n      },\n      {\n        Header: \"Trip Status\",\n        accessor: \"jsonPayload.response.status\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"TRIP_STATUS_\" />\n        ),\n      },\n      {\n        Header: \"Nav Status\",\n        accessor: \"jsonPayload.response.navStatus\",\n        Cell: ({ cell: { value } }) => (\n          <TrimCell value={value} trim=\"NAVIGATION_STATUS_\" />\n        ),\n      },\n    ];\n\n    // Add dynamic columns\n    _.map(props.extraColumns, (dotPath) => {\n      const elems = dotPath.split(\".\");\n      stdColumns.push({\n        Header: elems[elems.length - 1],\n        accessor: dotPath,\n      });\n    });\n    const headers = [\n      {\n        Header: \"Log Entries (click row to view full log entry)\",\n        columns: stdColumns,\n      },\n    ];\n    return headers;\n  }, [props.extraColumns]);\n\n  return (\n    <Styles>\n      <Table\n        columns={columns}\n        data={data}\n        onSelectionChange={props.onSelectionChange}\n      />\n    </Styles>\n  );\n}\n\nexport { LogTable as default };\n","/*\n * ToggleBar.js\n *\n * Row of buttons that configure visualization options on the map\n */\nimport styled from \"styled-components\";\nconst Button = styled.button``;\nconst ButtonToggle = styled(Button)`\n  opacity: 0.6;\n  ${({ active }) =>\n    active &&\n    `\n    opacity: 1;\n    color: Green;\n  `}\n`;\n\nconst docLinks = {\n  showGPSBubbles:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/GPSAccuracy.md\",\n  showHeading:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Heading.md\",\n  showSpeed:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/Speed.md\",\n  showDwellLocations:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/DwellTimes.md\",\n  showHighVelocityJumps:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/VelocityJumps.md\",\n  showMissingUpdates:\n    \"https://github.com/googlemaps/fleet-debugger/blob/main/docs/MissingUpdates.md\",\n};\n\nconst ButtonGroup = styled.div`\n  display: flex;\n`;\nfunction ToggleBar(props) {\n  // TODO: learn JSX ... make this a for loop\n  return (\n    <ButtonGroup>\n      <ButtonToggle\n        active={props.showGPSBubbles}\n        onClick={props.onClickGPSBubbles}\n      >\n        GPS Accuracy\n        <a href={docLinks.showGPSBubbles} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle active={props.showHeading} onClick={props.onClickHeading}>\n        Heading\n        <a href={docLinks.showHeading} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle active={props.showSpeed} onClick={props.onClickSpeed}>\n        Speed\n        <a href={docLinks.showSpeed} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle\n        active={props.showDwellLocations}\n        onClick={props.onClickDwellLocations}\n      >\n        Dwell Locations\n        <a href={docLinks.showDwellLocations} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle\n        active={props.showHighVelocityJumps}\n        onClick={props.onClickHighVelocityJumps}\n      >\n        Jumps (unrealistic velocity)\n        <a\n          href={docLinks.showHighVelocityJumps}\n          target=\"_blank\"\n          rel=\"noreferrer\"\n        >\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle\n        active={props.showMissingUpdates}\n        onClick={props.onClickMissingUpdates}\n      >\n        Jumps (Temporal)\n        <a href={docLinks.showMissingUpdates} target=\"_blank\" rel=\"noreferrer\">\n          ?\n        </a>\n      </ButtonToggle>\n      <ButtonToggle\n        active={props.showClientServerTimeDeltas}\n        onClick={props.onClickClientServerTimeDeltas}\n      >\n        Client/Server Time Deltas\n      </ButtonToggle>\n      <ButtonToggle active={props.showTraffic} onClick={props.onClickTraffic}>\n        Traffic\n      </ButtonToggle>\n      <ButtonToggle active={props.showLiveJS} onClick={props.onClickLiveJS}>\n        Start Live Journey Sharing for newest trip\n      </ButtonToggle>\n    </ButtonGroup>\n  );\n}\n\nexport default ToggleBar;\n","/*\n * vehicleData.js\n *\n * Load raw log data for easier consumption by other components.\n * In theory this could be done serverside & placed into rawData, but\n * it's easier to iterate on features when the raw log data doesn't need\n * to be regenerated each time\n */\nimport TripLogs from \"./TripLogs\";\nlet jwt;\nlet projectId;\nlet apikey;\nlet solutionType;\nlet tripLogs;\n\nasync function loadData() {\n  const response = await fetch(\"./data.json\");\n  const parsedData = await response.json();\n  jwt = parsedData.jwt;\n  projectId = parsedData.projectId;\n  apikey = parsedData.APIKEY;\n  solutionType = parsedData.solutionType;\n  tripLogs = new TripLogs(parsedData.rawLogs, solutionType);\n}\n\nexport { loadData, tripLogs, apikey, jwt, projectId, solutionType };\n","/*\n * App.js\n *\n * Basic react app container.  Handles state for the app and\n * propagation for state changes into the non-react map\n */\nimport React from \"react\";\nimport {\n  onSliderChangeMap,\n  addMarkersToMapForData,\n  updateMapToggles,\n  registerHandlers,\n} from \"./Map\";\nimport Dataframe from \"./Dataframe\";\nimport TimeSlider from \"./TimeSlider\";\nimport LogTable from \"./LogTable\";\nimport ToggleBar from \"./ToggleBar\";\nimport _ from \"lodash\";\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    const nowDate = new Date();\n    this.logData = props.logData;\n    this.state = {\n      timeRange: {\n        minTime: 0,\n        // default max time to 1 year in the future\n        maxTime: nowDate.setFullYear(nowDate.getFullYear() + 1),\n      },\n      featuredObject: { msg: \"Click a table row to select object\" },\n      extraColumns: [],\n      toggleOptions: {\n        showGPSBubbles: false,\n        showHeading: false,\n        showSpeed: false,\n        showTraffic: false,\n        showDwellLocations: false,\n        showHighVelocityJumps: false,\n        showMissingUpdates: false,\n        showLiveJS: false,\n        showClientServerTimeDeltas: false,\n      },\n    };\n    // Realtime updates are too heavy.  There must be a better/ react way\n    this.onSliderChangeDebounced = _.debounce(\n      (timeRange) => this.onSliderChange(timeRange),\n      25\n    );\n\n    // Allow map code to set which object is featured, and\n    // adjust the timerange filtering\n    registerHandlers(\n      (fo) => this.setFeaturedObject(fo),\n      (minTime, maxTime) => this.setTimeRange(minTime, maxTime)\n    );\n  }\n\n  updateColumns(toggleName, jsonPaths) {\n    this.setState((prevState) => {\n      const newValue = !prevState.toggleOptions[toggleName];\n      prevState.toggleOptions[toggleName] = newValue;\n      updateMapToggles(toggleName, newValue);\n\n      const extraColumns = _.clone(prevState.extraColumns);\n      _.forEach(jsonPaths, (path) => {\n        if (newValue) {\n          extraColumns.push(path);\n        } else {\n          _.pull(extraColumns, path);\n        }\n      });\n      prevState.extraColumns = extraColumns;\n\n      return prevState;\n    });\n  }\n\n  /*\n   * Updates react state assocated with the gps bubbles, including\n   * adding/removing appropriate rows in the log viewer\n   */\n  onClickGPSBubbles() {\n    this.updateColumns(\"showGPSBubbles\", [\n      \"jsonPayload.request.vehicle.lastLocation.rawLocationAccuracy\",\n      \"jsonPayload.request.vehicle.lastLocation.locSensor\",\n    ]);\n  }\n\n  /*\n   * Updates react state assocated with the heading arrows, including\n   * adding/removing appropriate rows in the log viewer\n   */\n  onClickHeading() {\n    this.updateColumns(\"showHeading\", [\n      \"jsonPayload.request.vehicle.lastLocation.heading\",\n      \"jsonPayload.request.vehicle.lastLocation.bearingAccuracy\",\n    ]);\n  }\n\n  /*\n   * Updates react state assocated with the speed bubbles, including\n   * adding/removing appropriate rows in the log viewer\n   */\n  onClickSpeed() {\n    this.updateColumns(\"showSpeed\", [\n      \"jsonPayload.request.vehicle.lastLocation.speed\",\n    ]);\n  }\n\n  /*\n   * Updates react state assocated with the traffic layer\n   */\n  onClickTraffic() {\n    this.updateColumns(\"showTraffic\", []);\n  }\n\n  /*\n   * Updates react state assocated with the dwellLocations layer\n   */\n  onClickDwellLocations() {\n    this.updateColumns(\"showDwellLocations\", []);\n  }\n\n  /*\n   * Updates react state assocated with the high velocity jumps layer\n   */\n  onClickHighVelocityJumps() {\n    this.updateColumns(\"showHighVelocityJumps\", [\n      \"jsonPayload.request.vehicle.lastLocation.speed\",\n    ]);\n  }\n\n  /*\n   * Updates react state assocated with the missing updates layer\n   */\n  onClickMissingUpdates() {\n    this.updateColumns(\"showMissingUpdates\", [\"jsonPayload.temporal_gap\"]);\n  }\n\n  /*\n   * Updates react state assocated with the missing updates layer\n   */\n  onClickClientServerTimeDeltas() {\n    this.updateColumns(\"showClientServerTimeDeltas\", [\n      \"jsonPayload.response.lastLocation.rawLocationTime\",\n      \"jsonPayload.response.lastLocation.serverTime\",\n    ]);\n  }\n\n  /*\n   * Updates react state assocated with the live journey sharing\n   */\n  onClickLiveJS() {\n    this.updateColumns(\"showLiveJS\", []);\n  }\n\n  /*\n   * Updates react state associated with the slider and calls into\n   * the non-react map code to do the same.\n   */\n  onSliderChange(timeRange) {\n    this.setTimeRange(timeRange.minTime, timeRange.maxTime);\n  }\n\n  /*\n   * Callback to updated selected log row\n   */\n  onSelectionChange(selectedRow) {\n    addMarkersToMapForData(selectedRow);\n    this.setFeaturedObject(selectedRow);\n  }\n\n  /*\n   * Set the featured object\n   */\n  setFeaturedObject(featuredObject) {\n    this.setState({ featuredObject: featuredObject });\n  }\n\n  /*\n   * exposes editing of the timeRange state\n   */\n  setTimeRange(minTime, maxTime) {\n    this.setState({\n      timeRange: {\n        minTime: minTime,\n        maxTime: maxTime,\n      },\n    });\n\n    // Handle Map component separately from standard state update\n    onSliderChangeMap(minTime, maxTime);\n  }\n\n  /*\n   * Callback to handle clicks on properties in the json viewer.\n   * Adds/removes row from the log viewer based on which property\n   * in the json object was clicked on\n   */\n  onDataframePropClick(select) {\n    this.setState((prevState) => {\n      const jsonPath = _.join(select.namespace, \".\") + \".\" + select.name;\n      let newColumns;\n      if (_.find(prevState.extraColumns, (x) => x === jsonPath)) {\n        newColumns = _.without(prevState.extraColumns, jsonPath);\n      } else {\n        newColumns = [...prevState.extraColumns, jsonPath];\n      }\n      return {\n        extraColumns: newColumns,\n      };\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <TimeSlider\n          logData={this.logData}\n          curMin={this.state.timeRange.minTime}\n          curMax={this.state.timeRange.maxTime}\n          onSliderChange={this.onSliderChangeDebounced}\n        />\n        <ToggleBar\n          showGPSBubbles={this.state.toggleOptions.showGPSBubbles}\n          onClickGPSBubbles={() => this.onClickGPSBubbles()}\n          showSpeed={this.state.toggleOptions.showSpeed}\n          onClickSpeed={() => this.onClickSpeed()}\n          showHeading={this.state.toggleOptions.showHeading}\n          onClickHeading={() => this.onClickHeading()}\n          showTraffic={this.state.toggleOptions.showTraffic}\n          onClickTraffic={() => this.onClickTraffic()}\n          showDwellLocations={this.state.toggleOptions.showDwellLocations}\n          onClickDwellLocations={() => this.onClickDwellLocations()}\n          showHighVelocityJumps={this.state.toggleOptions.showHighVelocityJumps}\n          onClickHighVelocityJumps={() => this.onClickHighVelocityJumps()}\n          showMissingUpdates={this.state.toggleOptions.showMissingUpdates}\n          onClickMissingUpdates={() => this.onClickMissingUpdates()}\n          showLiveJS={this.state.toggleOptions.showLiveJS}\n          onClickLiveJS={() => this.onClickLiveJS()}\n          showClientServerTimeDeltas={\n            this.state.toggleOptions.showClientServerTimeDeltas\n          }\n          onClickClientServerTimeDeltas={() =>\n            this.onClickClientServerTimeDeltas()\n          }\n        />\n        <div style={{ width: \"100%\", marginTop: \"20px\" }}>\n          <div\n            style={{\n              width: \"65%\",\n              overflowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n              float: \"left\",\n            }}\n          >\n            <LogTable\n              logData={this.logData}\n              style={{ width: \"100%\" }}\n              timeRange={this.state.timeRange}\n              extraColumns={this.state.extraColumns}\n              onSelectionChange={(featuredObject) =>\n                this.onSelectionChange(featuredObject)\n              }\n            />\n          </div>\n          <div\n            style={{\n              marginLeft: \"65%\",\n              overFlowX: \"scroll\",\n              overFlowY: \"scroll\",\n              height: \"100%\",\n            }}\n          >\n            <Dataframe\n              featuredObject={this.state.featuredObject}\n              onClick={(select) => this.onDataframePropClick(select)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { App as default };\n","class Utils {\n  /*\n   * Formats a duration into something friendly\n   * for human consumption.\n   */\n  static formatDuration(duration) {\n    let sec_num = duration / 1000;\n    let hours = Math.floor(sec_num / 3600);\n    let minutes = Math.floor((sec_num - hours * 3600) / 60);\n    let seconds = Math.floor(sec_num - hours * 3600 - minutes * 60);\n    let timeStr = \"\";\n\n    if (hours > 0) {\n      timeStr += hours + \" hours \";\n    }\n    if (minutes > 0) {\n      timeStr += minutes + \" minutes \";\n    }\n    if (seconds > 0) {\n      timeStr += seconds + \" seconds\";\n    }\n    return timeStr;\n  }\n}\nexport { Utils as default };\n","/*\n * Trip.js\n *\n * Processed log for a trip. Currently only includes very basic information\n * about the trip\n */\nimport _ from \"lodash\";\nimport Utils from \"./Utils\";\n\nclass Trip {\n  constructor(tripIdx, tripName, firstUpdate) {\n    this.tripIdx = tripIdx;\n    this.tripName = tripName;\n    this.updateRequests = 1;\n    this.pathCoords = [];\n    this.tripDuration = 0;\n    this.creationTime = \"Unknown\";\n    this.firstUpdate = firstUpdate;\n    this.lastUpdate = \"Unknown\";\n  }\n\n  getTraveledDistance() {\n    return window.google.maps.geometry.spherical.computeLength(this.pathCoords);\n  }\n\n  /*\n   * Returns data about trip to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      updateRequests: this.updateRequests,\n      tripName: this.tripName,\n      duration: Utils.formatDuration(this.tripDuration),\n      creationTime: this.creationTime,\n      traveledDistanceKilometers: this.getTraveledDistance() / 1000,\n      traveledDistanceMiles: this.getTraveledDistance() / 1609,\n      firstUpdate: this.firstUpdate,\n      lastUpdate: this.lastUpdate,\n    };\n  }\n\n  getPathCoords(minDate, maxDate) {\n    if (!(minDate && maxDate)) {\n      return this.pathCoords;\n    }\n    return _(this.pathCoords)\n      .filter((le) => {\n        return le.date >= minDate && le.date <= maxDate;\n      })\n      .value();\n  }\n\n  // append full raw log? would make downstream processing easier\n  // or synthesize pathCoords on the fly?\n  appendCoords(lastLocation, timestamp) {\n    this.pathCoords.push({\n      lat: lastLocation.rawLocation.latitude,\n      lng: lastLocation.rawLocation.longitude,\n      trip_id: this.tripName,\n      date: new Date(timestamp),\n    });\n  }\n}\nexport { Trip as default };\n","/*\n * stats helpers\n */\nclass Stats {\n  static median(dataSet) {\n    if (dataSet.length === 1) return dataSet[0];\n    const sorted = [...dataSet].sort();\n    const ceil = Math.ceil(sorted.length / 2);\n    const floor = Math.floor(sorted.length / 2);\n    if (ceil === floor) return sorted[floor];\n    return (sorted[ceil] + sorted[floor]) / 2;\n  }\n}\nexport { Stats as default };\n","/*\n * HighVelocityJump.js\n *\n * Representation of a HighVelocityJump\n */\nimport _ from \"lodash\";\nconst velocityOutlier = 68; // true velocities higher than this unlikely (in Meters/sec aprrox 150 MPH)\nimport Stats from \"./Stats\";\nlet computedOutlier = 0;\n\nclass HighVelocityJump {\n  constructor(jumpIdx, prevEntry, curEntry) {\n    const prevLoc = _.get(\n      prevEntry,\n      \"jsonPayload.request.vehicle.lastLocation\"\n    );\n    const curLoc = _.get(curEntry, \"jsonPayload.request.vehicle.lastLocation\");\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    const distanceTraveled =\n      window.google.maps.geometry.spherical.computeDistanceBetween(\n        startLoc,\n        endLoc\n      );\n    const timeSpentMS = curEntry.date - prevEntry.date;\n    const velocity = distanceTraveled / (timeSpentMS / 1000.0);\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.timeSpentMS = timeSpentMS;\n    this.distanceTraveled = distanceTraveled;\n    this.velocity = velocity;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.jumpIdx = jumpIdx;\n  }\n\n  /*\n   * Returns data about the jump to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      timeSpentMS: this.timeSpentMS,\n      distanceTraveled: this.distanceTraveled,\n      velocity: this.velocity,\n      velocityMPH: this.velocity * 2.237,\n      startLoc: this.startLoc.toString(),\n      startDate: this.prevEntry.date,\n      endDate: this.entry.date,\n      endLoc: this.endLoc.toString(),\n      jumpIdx: this.jumpIdx,\n      date: this.entry.date,\n      computedOutlierVelocity: computedOutlier,\n    };\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Jump\",\n      request: {\n        vehicle: {\n          lastLocation: {\n            speed: this.velocity,\n          },\n        },\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters jumps down to instances where the vehicle was\n   * travelling at an unrealistic speed (either\n   * greater that 150 MPH, or 100x median velocity).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantJumps(jumps) {\n    if (!jumps) {\n      return [];\n    }\n    const velocities = _.map(jumps, \"velocity\");\n    const avgVelocity = _.mean(velocities);\n    const medianVelocity = Stats.median(velocities);\n    const minVelocity = _.min(velocities);\n    const maxVelocity = _.max(velocities);\n    console.log(\"avgVelocity\", avgVelocity);\n    console.log(\"medianVelocity\", medianVelocity);\n    console.log(\"minVelocity\", minVelocity);\n    console.log(\"maxVelocity\", maxVelocity);\n    computedOutlier = _.min([velocityOutlier, medianVelocity * 100]);\n    return _(jumps)\n      .filter((e) => e.velocity >= computedOutlier)\n      .sortBy(\"velocity\")\n      .value();\n  }\n}\nexport { HighVelocityJump as default };\n","/*\n * MissingUpdate.js\n *\n * Representation of a missing update\n */\nimport _ from \"lodash\";\nconst updateOutlier = 60000; // 60 seconds\nimport Stats from \"./Stats\";\nimport Utils from \"./Utils\";\nlet computedOutlier = 0;\n\nclass MissingUpdate {\n  constructor(idx, prevEntry, curEntry) {\n    const interval = curEntry.date - prevEntry.date;\n    const curLoc = _.get(curEntry, \"jsonPayload.request.vehicle.lastLocation\");\n    const prevLoc = _.get(\n      prevEntry,\n      \"jsonPayload.request.vehicle.lastLocation\"\n    );\n    const startLoc = new google.maps.LatLng({\n      lat: prevLoc.rawLocation.latitude,\n      lng: prevLoc.rawLocation.longitude,\n    });\n    const endLoc = new google.maps.LatLng({\n      lat: curLoc.rawLocation.latitude,\n      lng: curLoc.rawLocation.longitude,\n    });\n    this.entry = curEntry;\n    this.prevEntry = prevEntry;\n    this.interval = interval;\n    this.startLoc = startLoc;\n    this.startDate = prevEntry.date;\n    this.endDate = curEntry.date;\n    this.endLoc = endLoc;\n    this.idx = idx;\n    this.startVehicleState = _.get(curEntry, \"jsonPayload.response.state\");\n    this.endVehicleState = _.get(prevEntry, \"jsonPayload.response.state\");\n    this.duration = Utils.formatDuration(this.interval);\n  }\n\n  /*\n   * Returns data about the update to show in json viewer\n   */\n  getFeaturedData() {\n    return {\n      duration: this.duration,\n      interval: this.interval,\n      startDate: this.startDate,\n      startLoc: this.startLoc.toString(),\n      endDate: this.endDate,\n      endLoc: this.endLoc.toString(),\n      startVehicleState: this.startVehicleState,\n      endVehicleState: this.endVehicleState,\n      computedOutlier: Utils.formatDuration(computedOutlier),\n    };\n  }\n\n  /*\n   * format a vehicle state transitino into something a\n   * human can easily read.\n   */\n  getStateTransition() {\n    const start = this.startVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    const end = this.endVehicleState.replace(\"VEHICLE_STATE_\", \"\");\n    return start + \">\" + end;\n  }\n\n  /*\n   * returns blob of data suitable for viewing in\n   * the log viewer\n   */\n  getLogViewerEntry() {\n    const featureData = this.getFeaturedData();\n    // Add properties necessary for logviewer to\n    // function\n    featureData.date = this.startDate;\n    featureData.timestampMS = this.startDate.getTime();\n    featureData.formattedDate = this.startDate.toISOString();\n    featureData.jsonPayload = {\n      \"@type\": \"Missing Updates\",\n      temporal_gap: featureData.duration,\n      response: {\n        state: this.getStateTransition(),\n      },\n    };\n    return featureData;\n  }\n\n  /*\n   * Filters updates down to instances where now updates\n   * were received from the vehicle for either 60 seconds\n   * or 10x the median observed update (our default\n   * update is every 5 seconds).\n   *\n   * These numbers were chosen somewhat arbitrarily\n   * based on a small dataset.\n   */\n  static getSignificantMissingUpdates(updates) {\n    if (!updates) {\n      return [];\n    }\n    const intervals = _.map(updates, \"interval\");\n    const avgInternal = _.mean(intervals);\n    const medianInternal = Stats.median(intervals);\n    const minInternal = _.min(intervals);\n    const maxInternal = _.max(intervals);\n    console.log(\"avgInternal\", avgInternal);\n    console.log(\"medianInternal\", medianInternal);\n    console.log(\"minInternal\", minInternal);\n    console.log(\"maxInternal\", maxInternal);\n    console.log(\"updateOutlier\", updateOutlier);\n    computedOutlier = _.min([medianInternal * 10, updateOutlier]);\n    console.log(\"computedOutlier\", computedOutlier);\n    return _(updates)\n      .filter((e) => e.interval >= computedOutlier)\n      .sortBy(\"interval\")\n      .value();\n  }\n}\nexport { MissingUpdate as default };\n","/*\n * TripLogs.js\n *\n * Processes raw logs into 'trip segments'.  A trip segment might\n * be an individual trip, a contiguous non-trip region, or the route\n * between two LMFS stops.\n */\nimport _ from \"lodash\";\nimport Trip from \"./Trip\";\nimport HighVelocityJump from \"./HighVelocityJump\";\nimport MissingUpdate from \"./MissingUpdate\";\n\nconst maxDistanceForDwell = 20; // meters\nconst requiredUpdatesForDwell = 12; // aka 2 minute assuming update vehicle request at 10 seconds\n\nclass TripLogs {\n  constructor(rawLogs, solutionType) {\n    this.solutionType = solutionType;\n    if (this.solutionType === \"LMFS\") {\n      this.updateVehicleSuffix = \"update_delivery_vehicle\";\n      this.lastLocationPath =\n        \"jsonPayload.request.deliveryVehicle.lastLocation\";\n    } else {\n      this.updateVehicleSuffix = \"update_vehicle\";\n      this.vehicleName = \"vehicle\";\n      this.lastLocationPath = \"jsonPayload.request.vehicle.lastLocation\";\n    }\n    this.trip_ids = [];\n    this.trips = [];\n    this.tripStatusChanges = [];\n    this.rawLogs = _.reverse(rawLogs);\n    this.processTripSegments();\n    this.minDate = new Date(rawLogs[0].timestamp);\n    this.maxDate = new Date(_.last(rawLogs).timestamp);\n    this.velocityJumps = [];\n    this.missingUpdates = [];\n    this.dwellLocations = [];\n\n    //  annotate with Dates & timestapms\n    _.map(this.rawLogs, (le, idx) => {\n      le.date = new Date(le.timestamp);\n      le.formattedDate = le.date.toISOString();\n      le.timestampMS = le.date.getTime();\n      le.idx = idx;\n    });\n  }\n\n  getRawLogs_(minDate, maxDate) {\n    minDate = minDate || this.minDate;\n    maxDate = maxDate || this.maxDate;\n    return _(this.rawLogs).filter(\n      (le) => le.date >= minDate && le.date <= maxDate\n    );\n  }\n\n  getLogs_(minDate, maxDate) {\n    return this.getRawLogs_(minDate, maxDate)\n      .concat(this.velocityJumps.map((j) => j.getLogViewerEntry()))\n      .concat(this.missingUpdates.map((u) => u.getLogViewerEntry()))\n      .filter((le) => le.date >= minDate && le.date <= maxDate)\n      .sortBy(\"timestampMS\");\n  }\n\n  getTripStatusChanges() {\n    return this.tripStatusChanges;\n  }\n\n  getTripStatusAtDate(date) {\n    const idx = _.sortedIndexBy(this.tripStatusChanges, { date }, \"date\");\n    if (idx >= 1) {\n      return this.tripStatusChanges[idx - 1].newStatus;\n    }\n  }\n\n  getTripIDs() {\n    // TODO: do time filtering heree\n    return this.trip_ids;\n  }\n\n  getTrips() {\n    // TODO: do time filtering heree\n    return this.trips;\n  }\n\n  /*\n   * Vehicles should be updating positions every 5 seconds\n   * (configurable?).  Compute places where updates are missing.\n   * aka \"Temporal jumps\".  This will be places where the\n   * app crashed, the user went off line, lost cell signal, etc.\n   */\n  getMissingUpdates(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new MissingUpdate(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.missingUpdates = MissingUpdate.getSignificantMissingUpdates(entries);\n    return this.missingUpdates;\n  }\n\n  /*\n   * Computes & returns jumps where the vehicle moved\n   * at an unrealistic velocity.\n   */\n  getHighVelocityJumps(minDate, maxDate) {\n    let prevEntry;\n    let entries = this.getRawLogs_(minDate, maxDate)\n      .filter((le) => _.get(le, this.lastLocationPath + \".rawLocation\"))\n      .map((curEntry) => {\n        let ret;\n        if (prevEntry) {\n          ret = new HighVelocityJump(curEntry.idx, prevEntry, curEntry);\n        }\n\n        prevEntry = curEntry;\n        return ret;\n      })\n      .compact()\n      .value();\n\n    this.velocityJumps = HighVelocityJump.getSignificantJumps(entries);\n    return this.velocityJumps;\n  }\n\n  /*\n   * Rudimentary dwell location compution.  A lot of issues:\n   *    - Uses size of circle to represent dwell times ... which is confusing\n   *      w.r.t which points make up this cluster. (ie overlapping circles when\n   *      dwell locations are close by).  Should those dwell locations merged?\n   *    - Doesn't compute an actual dwell time, instead assumes UpdateVehicle requests\n   *      are 10 seconds apart\n   *    - A cluster should be within maxDistanceForDwell as well as maxTime in order to be considered\n   *      (right now clusters can be created at a location where multiple trips over days cross)\n   *    - dwell times are fuzzy. Sliders for the time & distance components might be interesting\n   *    - Doesn't respect min/max time filters from the time slider\n   *    - computation of dwell times is slow -- should cache results when turning on & off to avoid\n   *      unnecessary precomputation\n   *    - dwellLocations could be sarted by time to improve cluster lookup\n   *\n   *  See https://stackoverflow.com/questions/36928654/leader-clustering-algorithm-explanation for a\n   *  description of the very simplistic algo used here.\n   */\n  getDwellLocations(minDate, maxDate) {\n    const dwellLocations = [];\n    _.forEach(this.rawLogs, (le) => {\n      const lastLocation = _.get(le, this.lastLocationPath);\n      if (\n        !lastLocation ||\n        !lastLocation.rawLocation ||\n        le.date < minDate ||\n        le.date > maxDate\n      ) {\n        return;\n      }\n      const coord = {\n        lat: lastLocation.rawLocation.latitude,\n        lng: lastLocation.rawLocation.longitude,\n      };\n      const cluster = _.find(\n        dwellLocations,\n        (dl) =>\n          window.google.maps.geometry.spherical.computeDistanceBetween(\n            dl.leaderCoords,\n            new google.maps.LatLng(coord)\n          ) <= maxDistanceForDwell\n      );\n      if (cluster) {\n        cluster.updates++;\n      } else {\n        dwellLocations.push({\n          leaderCoords: new window.google.maps.LatLng(coord),\n          updates: 1,\n        });\n      }\n    });\n\n    this.dwellLocations = _.filter(\n      dwellLocations,\n      (dl) => dl.updates >= requiredUpdatesForDwell\n    );\n\n    return this.dwellLocations;\n  }\n\n  getSegmentID(logEntry) {\n    if (this.solutionType === \"LMFS\") {\n      const stopsLeft = _.get(\n        logEntry,\n        \"jsonPayload.response.remainingVehicleJourneySegments\"\n      );\n      return stopsLeft && \"Stops Left \" + stopsLeft.length;\n    } else {\n      return _.get(logEntry, \"labels.trip_id\");\n    }\n  }\n\n  processTripSegments() {\n    let curTripId = \"this is not a segment\";\n    let curTripData = undefined;\n    let tripIdx = 0;\n    let nonTripIdx = 0;\n    let lastTripStatus = \"no status\";\n    // assumes logs are already sorted\n    // also assumes out-of-order updates can't happen.  Unclear\n    // if this is a good assumption, but it might be worth it to call out\n    // places where it happens (since that might actually be a client bug).\n\n    _.forEach(this.rawLogs, (le) => {\n      if (le.logName.match(this.updateVehicleSuffix)) {\n        const newTripId = this.getSegmentID(le);\n        if (newTripId !== curTripId) {\n          curTripId = newTripId;\n          const tripName = newTripId\n            ? newTripId\n            : \"non-trip-segment-\" + nonTripIdx;\n          curTripData = new Trip(tripIdx, tripName, new Date(le.timestamp));\n          this.trips.push(curTripData);\n          this.trip_ids.push(curTripData.tripName);\n\n          tripIdx++;\n          if (newTripId === undefined) {\n            nonTripIdx++;\n          }\n        } else {\n          curTripData.lastUpdate = new Date(le.timestamp);\n          curTripData.tripDuration =\n            curTripData.lastUpdate - curTripData.firstUpdate;\n          curTripData.updateRequests++;\n        }\n        const lastLocation = _.get(le, this.lastLocationPath);\n        if (lastLocation && lastLocation.rawLocation) {\n          curTripData.appendCoords(lastLocation, le.timestamp);\n        }\n      }\n      const tripStatus = _.get(le, \"jsonPayload.response.status\");\n      // if the logs had a trip status, and it changeed update\n      if (tripStatus && tripStatus !== lastTripStatus) {\n        this.tripStatusChanges.push({\n          newStatus: tripStatus,\n          date: new Date(le.timestamp),\n        });\n        lastTripStatus = tripStatus;\n      }\n    });\n  }\n}\n\nexport { TripLogs as default };\n","/*\n * index.js\n */\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport Map from \"./Map\";\nimport {\n  tripLogs,\n  loadData,\n  apikey,\n  jwt,\n  projectId,\n  solutionType,\n} from \"./vehicleData\";\n\nloadData().then(() => {\n  const logData = {\n    tripLogs,\n    apikey,\n    jwt,\n    projectId,\n    solutionType,\n  };\n  ReactDOM.render(\n    <div>\n      <Map logData={logData} />\n      <App logData={logData} />\n    </div>,\n    document.getElementById(\"root\")\n  );\n});\n"],"sourceRoot":""}